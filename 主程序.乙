/* 主程序相关的 */
/* 作者：邵世雄 */

#引入 "主程序.头"
#引入 <标准输入输出.头>

#定义 键盘命令_指示灯	0xed

空 关闭_控制台任务(结构 任务 *任务);
空 关闭_控制台(结构 图层 *层);
结构 图层 *搜索_图层(结构 层管管理 *层管, 整型 mx, 整型 my);
结构 图层 *打开_奥米(结构 层管管理 *层管, 无符号 整型 内存总计, 结构 图层 *旧层);

空 入口(空)
{
	/* 系统 */
		结构 启动信息 *启信 = (结构 启动信息 *) 地址_启动信息;
		结构 内存管理 *内存管理 = (结构 内存管理 *) 内存管理_地址;
		无符号 整型 内存总计;
		结构 先进先出32 先进先出, 键盘命令行;
		整型 先进先出缓存[128], 键盘命令_缓存[32];
		结构 任务 *任务_a, *任务;
		结构 文件信息 *文信;
		整型 *文件分配表;
		整型 小列表[M加基_M输入ID];
		整型 bpp = 获取_bpp();
	/* 键盘 */
		结构 鼠标_解 鼠解码;
		静态 字符 按键表格0[0x80] = {
			/* 一般文字 */
			  0, 0x01, '1',  '2', '3', '4', '5', '6', '7', '8', '9', '0',  '-',  '^', 0x08, 0x09,
			'Q',  'W', 'E',  'R', 'T', 'Y', 'U', 'I', 'O', 'P', '@', '[', 0x0a,    0,  'A',  'S',
			'D',  'F', 'G',  'H', 'J', 'K', 'L', ';', ':',   0,   0, ']',  'Z',  'X',  'C',  'V',
			'B',  'N', 'M',  ',', '.', '/',   0, '*',   0, ' ',   0,   0,    0,    0,    0,    0,
			  0,    0,   0,    0,   0,   0,   0, '7', '8', '9', '-', '4',  '5',  '6',  '+',  '1',
			'2',  '3', '0',  '.',   0,   0,   0,   0,   0,   0,   0,   0,    0,    0,    0,    0,
			  0,    0,   0,    0,   0,   0,   0,   0,   0,   0,   0,   0,    0,    0,    0,    0,
			  0,    0,   0, 0x5c,   0,   0,   0,   0,   0,   0,   0,   0,    0, 0x5c,    0,    0
		};
		静态 字符 按键表格1[0x80] = {
			/* 按下 shift */
			  0,    0, '!', 0x22, '#', '$', '%', '&', 0x27, '(', ')', '~',  '=', '~', 0x08, 0x09,
			'Q',  'W', 'E',  'R', 'T', 'Y', 'U', 'I',  'O', 'P', '`', '{', 0x0a,   0,  'A',  'S',
			'D',  'F', 'G',  'H', 'J', 'K', 'L', '+',  '*',   0,   0, '}',  'Z', 'X',  'C',  'V',
			'B',  'N', 'M',  '<', '>', '?',   0, '*',    0, ' ',   0,   0,    0,   0,    0,    0,
			  0,    0,   0,    0,   0,   0,   0, '7',  '8', '9', '-', '4',  '5', '6',  '+',  '1',
			'2',  '3', '0',  '.',   0,   0,   0,   0,    0,   0,   0,   0,    0,   0,    0,    0,
			  0,    0,   0,    0,   0,   0,   0,   0,    0,   0,   0,   0,    0,   0,    0,    0,
			  0,    0,   0,  '_',   0,   0,   0,   0,    0,   0,   0,   0,    0, '|',    0,    0
		};
		整型 键_上档 = 0, 键_控制 = 0, 键_换挡 = 0, 标记_e0 = 0;
		整型 键_指示灯状态 = (启信->指示灯状态 >> 4) & 7, 键盘命令_等待 = -1;
	/* 鼠标 */
		整型 mx, my, x = 0, y = 0, mmx = -1, mmy = -1, new_mx = -1, new_my = 0;
		整型 mmx2 = 0, new_wx = 0x7fffffff, new_wy = 0, 标记_鼠标 = 0;
	/* IME */
		无符号 字符 *汉语;
		外部 字符 美互标码[4096];
		整型 旧语言;
	/* 图层s */
		结构 层管管理 *层管;
		无符号 字符 *缓存_背层, *缓存_鼠标, *缓存_naomi;
		结构 图层  *层_背层, *层_鼠标, *层_naomi, *层 = 0, *键_窗, *层2 = 0;
	/* 气泡 */
		无符号 字符 *缓存_泡;
		结构 图层  *层_泡;
		结构 气泡 *开始菜单;
		整型 标记_泡 = 0;
	/* Misc */
		无符号 字符 s[40];
		整型 i, j;


	初始化_全局表中断表();
	初始化_片();
	出入流_许中断(); /* 由于IDT / 片的初始化结束，取消了CPU中断禁止 */
	先进先出32_初始化(&先进先出, 128, 先进先出缓存, 0);
	*((整型 *) 0x0fec) = (整型) &先进先出;
	初始化_pit();
	初始化_键盘(&先进先出, 256);
	启用_鼠标(&先进先出, 512, &鼠解码);
	出入流_输出8(片0_IMR, 0xf8); /* 允许PIT，片1和键盘(11111000) */
	出入流_输出8(片1_IMR, 0xef); /* 允许鼠标(11101111) */
	先进先出32_初始化(&键盘命令行, 32, 键盘命令_缓存, 0);

	内存总计 = 内存检测(0x00400000, 0xbfffffff);
	内存管理_初始化(内存管理);
	内存管理_空余(内存管理, 0x00001000, 0x0009e000); /*	0x00001000 - 0x0009efff */
	内存管理_空余(内存管理, 0x00400000, 内存总计 - 0x00400000);
	*((整型 *) 0x0fe2) = (整型) 内存总计;

	初始化_定时器ctl();
	初始化_调色板();
	层管 = 层管_初始化(内存管理, 启信->显存, 启信->屏幕横坐标, 启信->屏幕纵坐标);
	任务_a = 任务_初始化(内存管理);
	先进先出.任务 = 任务_a;
	任务_运行(任务_a, 1, 2);
	*((整型 *) 0x0fe4) = (整型) 层管;
	任务_a->语言模式 = 0;

	/* 层_背层 */
	层_背层 = 图层_分配(层管);
	缓存_背层 = (无符号 字符 *) 内存管理_分配_4096(内存管理, 启信->屏幕横坐标 * 启信->屏幕纵坐标 * (bpp >> 3));
	图层_设置缓存(层_背层,  缓存_背层,  启信->屏幕横坐标, 启信->屏幕纵坐标, -1);	/* 没有透明色 */
	初始化_屏幕((无符号 整型 *) 缓存_背层, 启信->屏幕横坐标, 启信->屏幕纵坐标);
	层_背层->旗帜 |= 0x01;	/* 背景 */

	/* 层_naomi */
	层_naomi = 图层_分配(层管);
	缓存_naomi = (无符号 字符 *) 内存管理_分配_4096(内存管理, 启信->屏幕横坐标 * 启信->屏幕纵坐标 * (bpp >> 3));
	图层_设置缓存(层_naomi, 缓存_naomi, 启信->屏幕横坐标,30, 99);	/* 透明色可用 */
	//初始化_任务((无符号 整型 *) 缓存_naomi, 启信->屏幕横坐标, 启信->屏幕纵坐标);
	实盒((无符号 整型 *)缓存_naomi, 启信->屏幕横坐标, 0x7A8A9D,  0,     0, 启信->屏幕横坐标 -  1, 启信->屏幕纵坐标 - 28);
	// 实盒((无符号 整型 *)缓存_naomi, 启信->屏幕横坐标, 0x7A8A9D,  0,     启信->屏幕纵坐标 - 28, 启信->屏幕横坐标 -  1, 启信->屏幕纵坐标 - 28);
	// 实盒((无符号 整型 *)缓存_naomi, 启信->屏幕横坐标, 0x000000,  0,     启信->屏幕纵坐标 - 27, 启信->屏幕横坐标 -  1, 启信->屏幕纵坐标 - 27);
	// 实盒((无符号 整型 *)缓存_naomi, 启信->屏幕横坐标, 0x7A8A9D,  0,     启信->屏幕纵坐标 - 26, 启信->屏幕横坐标 -  1, 启信->屏幕纵坐标 -  1);
	//放_naomi((无符号 整型 *) 缓存_naomi);
	
	// 整型 ix, t[3];
	// 字符 sx[5];
	// 循环 (ix = 0; ix < 3; ix++) 
	// {
		// t[ix] = 实时时钟_获取(ix+3);
	// }
	// spr整型f(sx, "%02d:%02d:%02d\n",  t[0], t[1],t[2]);
	打印字体_美互标码_层((无符号 整型 *)层_naomi, 9,7, 0xffffff, 0x7A8A9D,"菜单", 1);
	// 打印字体_美互标码_层((无符号 整型 *)层_naomi, 启信->屏幕横坐标-90,7, 0xffffff, 0x7A8A9D,sx, 1);
	图层_刷新(层_naomi, 0, 0, 层_naomi->b横坐标大小, 层_naomi->b纵坐标大小);
	层_naomi->旗帜 |= 0x100;	/* 特殊窗口 */
// ///时间
结构 任务 *时钟 = 任务_分配();
	整型 *时钟_先进先出 = (整型 *) 内存管理_分配_4096(内存管理, 128 * 4);
	时钟->tss.esp = 内存管理_分配_4096(内存管理, 64 * 1024) + 64 * 1024;
	时钟->tss.eip = (整型) &系统时钟_任务;
	时钟->tss.es = 1 * 8;
	时钟->tss.乙s = 2 * 8;
	时钟->tss.ss = 1 * 8;
	时钟->tss.ds = 1 * 8;
	时钟->tss.fs = 1 * 8;
	时钟->tss.gs = 1 * 8;
	任务_运行(时钟, 1, 2); /* 级别=1, 优先=2 */
	先进先出32_初始化(&时钟->先进先出, 128, 时钟_先进先出, 时钟);
// /* 层_窗_b */
 
// 结构 任务 *任务_时间;
	 
		// 层_naomi= 图层_分配(层管);
		// // 缓存_时间 = (无符号 字符 *) 内存管理_分配_4096(内存管理, 启信->屏幕横坐标 * 启信->屏幕纵坐标 * (bpp >> 3));
		// 图层_设置缓存(层_naomi, 缓存_naomi, 启信->屏幕横坐标,30, 99);	/* 透明色可用 */
		 
		// 任务_时间 = 任务_分配();
		// 任务_时间->tss.esp = 内存管理_分配_4096(内存管理, 64 * 1024) + 64 * 1024 - 8;
		// 任务_时间->tss.eip = (整型) &任务_时间_入口;
		// 任务_时间->tss.es = 1 * 8;
		// 任务_时间->tss.乙s = 2 * 8;
		// 任务_时间->tss.ss = 1 * 8;
		// 任务_时间->tss.ds = 1 * 8;
		// 任务_时间->tss.fs = 1 * 8;
		// 任务_时间->tss.gs = 1 * 8;
		// *((整型 *) (任务_时间->tss.esp + 4)) = (整型) 层_naomi;
		// 任务_运行(任务_时间, 2, -1);
			// 图层_slide(层_naomi,  0,  0);
			// 图层_up做wn(层_naomi, 10);
	 
/////////////////

///多任务
/* 层_窗_b */
// 结构 图层 *层_窗_b[3];
// 无符号 字符 *缓存_窗_b;
// 结构 任务 *任务_b[3];
	// 循环 (i = 0; i < 3; i++) {
		// 层_窗_b[i] = 图层_分配(层管);
		// 缓存_窗_b = (无符号 字符 *) 内存管理_分配_4096(内存管理, 启信->屏幕横坐标 * 启信->屏幕纵坐标 * (bpp >> 3));
		// 图层_设置缓存(层_窗_b[i], 缓存_窗_b, 144, 52, -1); /* 摟柧怓側偟 */
		// spr整型f(s, "任务_b%d", i);
		// 制作_窗体((无符号 整型 *) 缓存_窗_b, 144, 52, s, 0,0);
		// 任务_b[i] = 任务_分配();
		// 任务_b[i]->tss.esp = 内存管理_分配_4096(内存管理, 64 * 1024) + 64 * 1024 - 8;
		// 任务_b[i]->tss.eip = (整型) &任务_乙_入口;
		// 任务_b[i]->tss.es = 1 * 8;
		// 任务_b[i]->tss.乙s = 2 * 8;
		// 任务_b[i]->tss.ss = 1 * 8;
		// 任务_b[i]->tss.ds = 1 * 8;
		// 任务_b[i]->tss.fs = 1 * 8;
		// 任务_b[i]->tss.gs = 1 * 8;
		// *((整型 *) (任务_b[i]->tss.esp + 4)) = (整型) 层_窗_b[i];
		// 任务_运行(任务_b[i], 2, i + 1);
			// 图层_slide(层_窗_b[i],  0,  0);
			// 图层_up做wn(层_窗_b[i], 10+i);
	// }
/////////////////
	/* 层_泡 */
	层_泡 = 图层_分配(层管);
	缓存_泡 = (无符号 字符 *) 内存管理_分配_4096(内存管理,启信->屏幕横坐标 * 启信->屏幕纵坐标  *(bpp >> 3));
	图层_设置缓存(层_泡, 缓存_泡, 220,370,99);	/* 透明色可用 */
	// 开始菜单 = 制作_泡(内存管理, 层_泡, 0, 0, 6, 19, 1);
	 实盒((无符号 整型 *)缓存_泡, 启信->屏幕横坐标, 0xF0F0F0,  0,     0,  启信->屏幕横坐标 , 500);
	 打印字体_美互标码_层((无符号 整型 *)层_泡, 9,7, 0x000000,0xF0F0F0,"cmd", 1);
	 打印字体_美互标码_层((无符号 整型 *)层_泡, 9,25, 0x000000,0xF0F0F0,"shut做wn", 1);
	//图层_刷新(层_泡, 0, 0, 层_泡->b横坐标大小, 层_泡->b纵坐标大小);
	// 放入迷你字体_美互标码_层(层_泡, 4, 3, 0x000000, 0xffffff, "My 名称 is naomisan", 19);
	层_泡->旗帜 |= 0x100;	/* 特殊窗口 */

	/* 层_控制台 */
	键_窗 = 打开_控制台(层管, 内存总计);
 // show颜色();
	/* 层_鼠标 */
	层_鼠标 = 图层_分配(层管);
	缓存_鼠标 = (无符号 字符 *) 内存管理_分配_4096(内存管理, 16 * 16 * (bpp >> 3));
	图层_设置缓存(层_鼠标, 缓存_鼠标, 16, 16, 99);	/* 透明色号为99 */
	初始化_鼠标_光标((无符号 整型 *) 缓存_鼠标, 99/* 背景色 */);
	mx = (启信->屏幕横坐标 - 16) / 2; /* 按显示画面在中央计算坐标 */
	my = (启信->屏幕纵坐标 - 16) / 2;

	图层_slide(层_背层,  0,  0);
	 图层_slide(键_窗,   8, 16);
	图层_slide(层_泡, 0, 启信->屏幕纵坐标 - 370);
	图层_slide(层_naomi, 0, 启信->屏幕纵坐标 - 30);
	图层_slide(层_鼠标, mx, my);
	图层_up做wn(层_背层,  0);
	 //图层_up做wn(键_窗,   1);
	图层_up做wn(层_naomi, 2);
	图层_up做wn(层_鼠标, 10);
	// 图层_up做wn(层_泡, 2);
	键窗_打开(键_窗);

	/* 设置初始键盘状态 */
	先进先出32_放入(&键盘命令行, 键盘命令_指示灯);
	先进先出32_放入(&键盘命令行, 键_指示灯状态);

	/* 汉语.字体的读取 */
	文件分配表 = (整型 *) 内存管理_分配_4096(内存管理, 4 * 2880);
	文件_读取文件(文件分配表, (无符号 字符 *) (地址_磁盘镜像 + 0x000200));
	文信 = 文件_搜索("汉语.字体", (结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
	若 (文信 != 0) 
	{
		i = 文信->大小;
		汉语 = 文件_加载文件2(文信->clustno, &i, 文件分配表);
	} 
	则 
	{
		汉语 = (无符号 字符 *) 内存管理_分配_4096(内存管理, 16 * 256 + 32 * 94 * 47);
		循环 (i = 16 * 256; i < 16 * 256 + 32 * 94 * 47; i++) 
		{
			汉语[i] = 0xff;	/* 用0xff填充全宽部分 */
		}
	}
	循环 (i = 0; i < 16 * 256; i++) 
	{
		汉语[i] = 美互标码[i];	/* 复制半宽部分 */
	}
	*((整型 *) 0x0fe8) = (整型) 汉语;
	
	/*加载壁纸*/
	// 字符 *命令行x = (字符 *) 内存管理_分配_4096(内存管理, 10*10);
	// 命令行x[0]='c';
	// 命令行x[1]='i';
	// 命令行x[2]='t';
	// 命令行x[3]='y';
	// 命令行x[4]='.';
	// 命令行x[5]='j';
	// 命令行x[6]='p';
	// 命令行x[7]='g';	 		
	结构 照片 *壁纸 = 照片_初始化("city.jpg", 文件分配表);	 
	照片_绘画(层_背层, 壁纸, (层_背层->b横坐标大小-壁纸->信息[2])/2, (层_背层->b纵坐标大小-壁纸->信息[3])/2);
	照片_空余(壁纸);	 
	图层_刷新(层_背层, 0, 0, 层_背层->b横坐标大小, 层_背层->b纵坐标大小);
	
	/*加???*/
	// 结构 内存管理 *内存管理 = (结构 内存管理 *) 内存管理_地址;
	// 结构 文件信息 *文信;
	// 结构 任务 *任务 = 任务_当前();
	// 整型 i = 0, j, k, 标记 = 0;
	// 字符 s[30];
	i=0;
	整型  k,标记 = 0;
	无符号 字符 *目录列表 = 0;
	整型 目录列表_大小, dir_clustno;
 
		文信 = (结构 文件信息 *) (地址_磁盘镜像 + 0x002600);
	 	整型 xx=0,yy=0;
	循环 (i = 0; i < 224; i++) 
	{
		// 若 (i != 0 && (i % 11) == 0) {
			// 打印字体_美互标码_层((无符号 整型 *)层_背层, 9,75, 0x000000,0xF0F0F0,s, 1); 
			// 循环 (;;) {
				// 出入流_禁中断();
				// 若 (先进先出32_状态(&任务->先进先出) == 0) {
					// 任务_睡眠(任务);
					// 出入流_许中断();
				// } 则 {
					// k = 先进先出32_获取(&任务->先进先出);
					// 出入流_许中断();
					// 若 (256 <= k && k < 512) {
						// //控制台_新行(控制台);
						// 终止;
					// }
				// }
			// }
		// }
		若 (文信[i].名称[0] == 0x00) 
		{
			终止;
		}
		若 (文信[i].名称[0] != 0xe5) 
		{
			若 ((文信[i].类型 & 0x18) == 0) 
			{
				/* 普通文件 */
				// spr整型f(s, "文件名称", 文信[i].大小);
				循环 (j = 0; j < 8; j++) 
				{
					s[j] = 文信[i].名称[j];
				}
				// s[10] = 文信[i].ext[0];
				// s[11] = 文信[i].ext[1];
				// s[12] = 文信[i].ext[2];
				
				整型 *文件分配表1= (整型 *) 内存管理_分配_4096(内存管理, 4 * 2880);
 文件_读取文件(文件分配表1, (无符号 字符 *) (地址_磁盘镜像 + 0x000200));
	无符号 字符 *缓存_图标;
	结构 图层 *层_图标;
	层_图标 = 图层_分配(层管);
	缓存_图标 = (无符号 字符 *) 内存管理_分配_4096(内存管理, 启信->屏幕横坐标 * 启信->屏幕纵坐标 * (bpp >> 3));
	图层_设置缓存(层_图标,  缓存_图标,  32, 32, -1);	/* 没有透明的颜色 */
初始化_屏幕((无符号 整型 *) 缓存_图标, 启信->屏幕横坐标, 启信->屏幕纵坐标);	
	层_图标->旗帜 |= 0x01;	/* 背景 */
	
	// 字符 *命令行x1 = (字符 *) 内存管理_分配_4096(内存管理, 10*10);
	// 命令行x1[0]='n';
	// 命令行x1[1]='y';
	// 命令行x1[2]='a';
	// 命令行x1[3]='n';
	// 命令行x1[4]='p';
	// 命令行x1[5]='o';
	// 命令行x1[6]='.';
	// 命令行x1[7]='i';
	// 命令行x1[8]='c';
	// 命令行x1[9]='o';	
	结构 照片 *壁纸1 = 照片_初始化("nyanpo.图标", 文件分配表1);	 
	照片_绘画(层_图标, 壁纸1, (层_图标->b横坐标大小-壁纸1->信息[2])/2, (层_图标->b纵坐标大小-壁纸1->信息[3])/2);
	照片_空余(壁纸1);	 
	

		
	图层_slide(层_图标,  50*xx+20,  80*yy+10);
		图层_up做wn(层_图标,  1);
		
				打印字体_美互标码_层((无符号 整型 *)层_背层, 50*xx+20,80*yy+50, 0xFFFFFF,0x000000,s, 0); 
				// 打印字体_美互标码_层((无符号 整型 *)层_背层, 10,80*i+52, 0x413B31,0x000000,s, 0); 
				
				图层_刷新(层_图标, 0, 0, 层_图标->b横坐标大小, 层_图标->b纵坐标大小);
		图层_刷新(层_背层, 0, 0, 层_背层->b横坐标大小, 层_背层->b纵坐标大小);
		
		若(i == 7)
		{ 	xx=1;
			yy=0;
			}
	则{
		yy=yy+1;
	}
			} 
		}
	}
	// 若 (标记 == 1) {
			// 内存管理_空余_4096(内存管理, (整型) 目录列表, 目录列表_大小);
	// }
	 
	//计算机
	结构 图层 *层_计算机 = 图层_分配(层管);
	无符号 字符 *缓存_计算机 = (无符号 字符 *) 内存管理_分配_4096(内存管理, (600) * (400) * (bpp >> 3));
	图层_设置缓存(层_计算机, 缓存_计算机, 600, 400, -1);	/* 没有透明的颜色 */
	制作_窗体((无符号 整型 *) 缓存_计算机,600, 400, "wenjianguanli", 0, 0);
	图层_slide(层_计算机, 80, 80);
	图层_up做wn(层_计算机,  8);
	
	/* 开始up */
	文信 = 文件_搜索("ssxos.头sf", (结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
	j = 2;
	若 (文信 != 0) 
	{
		字符 *ss;
		i = 文信->大小;
		ss = 文件_加载文件2(文信->clustno, &i, 文件分配表);
		循环 (x = 0; x < i; x++) 
		{
			若 (ss[x] == '#' && j == 2) 
			{
				/* 如果该行的开头有＃，请将其注释掉 */
				j = 1;
			}
			若 (ss[x] == 0x0a) 
			{
				/* 由于已到达行尾，因此取消注释标记 */
				j = 2;
			}
			若 (ss[x] != 0x0d && j != 1) 
			{
				先进先出32_放入(&键_窗->任务->先进先出, ss[x] + 256);
			}
		}
		内存管理_空余_4096(内存管理, (整型) ss, i);
	}

	内存管理_空余_4096(内存管理, (整型) 文件分配表, 4 * 2880);

	/* 小列表的初始化 */
	循环(i = 0; i < M加基_M输入ID; i++) 
	{
		小列表[i] = -1;		/* 未使用 */
	}

	循环(;;) 
	{
		若 (先进先出32_状态(&键盘命令行) > 0 && 键盘命令_等待 < 0) 
		{
			/* 发送要发送到键盘的任何数据 */
			键盘命令_等待 = 先进先出32_获取(&键盘命令行);
			等待_键盘控制电路_发送就绪();
			出入流_输出8(端口_KEYDAT, 键盘命令_等待);
		}
		出入流_禁中断();
		若 (先进先出32_状态(&先进先出) == 0) 
		{
			/* 由于fifo已成为carappo，因此如果有待处理的绘图则执行 */
			若 (new_mx >= 0) 
			{
				出入流_许中断();
				图层_slide(层_鼠标, new_mx, new_my);
				new_mx = -1;
			} 
			则 若 (new_wx != 0x7fffffff) 
			{
				出入流_许中断();
				图层_slide(层, new_wx, new_wy);
				new_wx = 0x7fffffff;
			} 
			则 
			{
				任务_睡眠(任务_a);
				出入流_许中断();
			}
		} 
		则 
		{
			i = 先进先出32_获取(&先进先出);
			出入流_许中断();
			若 (键_窗 != 0 && 键_窗->旗帜 == 0) 
			{
				/* 输入窗口已关闭 */
				若 (层管->顶 == 2) 
				{
					/* 没有更多的鼠标和背景 */
					键_窗 = 0;
				} 
				则 
				{
					键_窗 = 层管->图层s[层管->顶 - 2];
					键窗_打开(键_窗);
				}
			}
			若 (256 <= i && i < 512) 
			{
				/* 键盘数据 */
				i -= 256;	// 先拉
				若 (i == 0xe0) 
				{
					/* E0扩展密钥 */
					标记_e0 = 1;
				}
				若 (i < 0x80 && 标记_e0 == 0) 
				{
					/* 将密钥代码转换为字符代码 */
					若 (键_上档 == 0) 
					{
						s[0] = 按键表格0[i];
					} 
					则 若 (键_上档 == 1) 
					{
						s[0] = 按键表格1[i];
					}
				} 
				则 
				{
					s[0] = 0;
				}
				若 ('A' <= s[0] && s[0] <= 'Z')	
				{
					/* 字母输入 */
					若 (((键_指示灯状态 & 4) == 0 && 键_上档 == 0) ||
						((键_指示灯状态 & 4) != 0 && 键_上档 != 0)   ) 
					{
						s[0] += 0x20;	/* 转换为小写 */
					}
				}
				若 (标记_e0 == 1) 
				{
					若 (i == 0x35 || i == 0x1c) 
					{
						/* /并输入 */
						s[0] = 按键表格0[i];
					}
				}
				若 (0x47 <= i && i <= 0x53) 
				{
					若 (i != 0x4a && i != 0x4e) 
					{
						/* 数字小键盘和输入s，Del，Home，end，PgUp，PgDn，光标键*/
						若 (标记_e0 == 1 || (键_指示灯状态 & 2) != 0) 
						{
							s[0] = 按键表格0[i] + 0x80;		// 一律に0x80を足す
						}
					}
				}
				若 (i == 0x0f && 键_换挡 != 0) 
				{
					/* Alt + Tab键不受代码传输的影响 */
					s[0] = 0;
				}
				若 (s[0] != 0 && 键_窗 != 0) 
				{
					/* 普通字符，Enter，BackSpace，Tab */
					若 (键_控制 == 0) 
					{
						/* 要控制台 */
						先进先出32_放入(&键_窗->任务->先进先出, s[0] + 256);
					}
				}
				若 (i == 0x57 && 层管->顶 > 2) 
				{
					/* F11键 */
					图层_up做wn(层管->图层s[1], 层管->顶 - 2);
				}
				若 (i == 0x2a)
					键_上档 |= 1;			// 左移on
				若 (i == 0x36)
					键_上档 |= 2;			// 右移on
				若 (i == 0xaa)
					键_上档 &= ~1;		// 左移off
				若 (i == 0xb6)
					键_上档 &= ~2;		// 右移off
				若 (i == 0x1d) {
					若 (标记_e0 == 0) 
					{
						键_控制 |= 1;		// 左CTRLon
					} 
					则 
					{
						键_控制 |= 2;		// 右CTRLon
					}
				}
				若 (i == 0x9d) 
				{
					若 (标记_e0 == 0) 
					{
						键_控制 &= ~1;		// 左CTRLoff
					} 
					则 
					{
						键_控制 &= ~2;		// 右CTRLoff
					}
				}
				若 (i == 0x38) 
				{
					若 (标记_e0 == 0) 
					{
						键_换挡 |= 1;		// 左ALTon
					}
					则 
					{
						键_换挡 |= 2;		// 右ALTon
					}
				}
				若 (i == 0xb8) 
				{
					若 (标记_e0 == 0) 
					{
						键_换挡 &= ~1;		// 左ALToff
					} 
					则 
					{
						键_换挡 &= ~2;		// 右ALToff
					}
				}
				若 (i == 0x3a) 
				{
					/* CapsLock */
					键_指示灯状态 ^= 4;
					先进先出32_放入(&键盘命令行, 键盘命令_指示灯);
					先进先出32_放入(&键盘命令行, 键_指示灯状态);
				}
				若 (i == 0x45) 
				{
					/* NumLock */
					键_指示灯状态 ^= 2;
					先进先出32_放入(&键盘命令行, 键盘命令_指示灯);
					先进先出32_放入(&键盘命令行, 键_指示灯状态);
				}
				若 (i == 0x46) 
				{
					/* ScrollLock */
					键_指示灯状态 ^= 1;
					先进先出32_放入(&键盘命令行, 键盘命令_指示灯);
					先进先出32_放入(&键盘命令行, 键_指示灯状态);
				}
				若 (((i == 0x0f && 键_换挡 != 0) || i == 0x43) && 键_窗 != 0) 
				{
					/* Tab修改了 Alt + Tab or F9 */
					键窗_关闭(键_窗);
					j = 键_窗->高 - 1;
					若 (j == 0) 
					{
						j = 层管->顶 - 2;
					}
					键_窗 = 层管->图层s[j];
					键窗_打开(键_窗);
				}
				若 (i == 0x2e && 键_控制 != 0 && 键_窗 != 0) 
				{
					/* Shift + F1修改了Ctrl + C. */
					任务 = 键_窗->任务;
					若 (任务 != 0 && 任务->tss.ss0 != 0) 
					{
						任务->语言模式 = 任务->语言模式0;	/* 撤消API更改的语言模式 */
						旧语言 = 任务_a->语言模式;		/* 暂时将task_a字模式与任务匹配 */
						任务_a->语言模式 = 任务->语言模式;
						控制台_打印字符0(任务->控制台, "\n终止(key) :\n");
						任务_a->语言模式 = 旧语言;
						出入流_禁中断();
						任务->tss.e加基 = (整型) &(任务->tss.esp0);
						任务->tss.eip = (整型) 甲语言_结束_应用;
						出入流_许中断();
						任务_运行(任务, -1, 0);
					}
				}
				若 (i == 0x31 && 键_控制 != 0) 
				{
					/* Sh若t + F2修改了 Ctrl + N */
					/* 激活新创建的控制台 */
					键窗_关闭(键_窗);
					键_窗 = 打开_控制台(层管, 内存总计);
					图层_slide(键_窗, 8, 16);
					图层_up做wn(键_窗, 层管->顶 - 1);
					键窗_打开(键_窗);
				}
				若 (i != 0xe0 && 标记_e0 == 1) 
				{
					/* E0扩展 */
					标记_e0 = 0;
				}
				若 (i == 0xfa) 
				{
					/* 键盘接收数据 */
					键盘命令_等待 = -1;
				}
				若 (i == 0xfe) 
				{
					/* 键盘无法接收数据 */
					等待_键盘控制电路_发送就绪();
					出入流_输出8(端口_KEYDAT, 键盘命令_等待);
				}
			} 
			则 若 (512 <= i && i < 768) 
			{
				/* 鼠标 */
				若 (鼠标_解码(&鼠解码, i - 512)) 
				{
					/* 鼠标移动 */
					mx += 鼠解码.x;
					my += 鼠解码.y;
					若 (mx < 0)
						mx = 0;
					若 (my < 0)
						my = 0;
					若 (mx > 启信->屏幕横坐标 - 1)
						mx = 启信->屏幕横坐标 - 1;
					若 (my > 启信->屏幕纵坐标 - 1)
						my = 启信->屏幕纵坐标 - 1;
					new_mx = mx;
					new_my = my;
					若 ((鼠解码.按钮 != 0 || 标记_鼠标 != 0) && mmx < 0) 
					{
						/* 停止制作 */
						/* 从底部开始按顺序搜索标签指向的工作表 */
						层 = 搜索_图层(层管, mx, my);
						x = mx - 层->vx0;
						y = my - 层->vy0;
						若 (鼠解码.按钮 != 0 && 层 != 层_naomi) 
						{
							图层_up做wn(层_泡, -1);	/* 擦除气球 */
							标记_泡 = 0;
						}
					}
					若 (鼠解码.按钮 & 0x01) 
					{
						/* 左键 */
						标记_鼠标 |= 0x01;
						若 (mmx < 0) 
						{
							/* 正常模式 */
							若 ((层->旗帜 & 0x100) != 0) 
							{
								/* Naomi-san或开始菜单 */
								若 (层 == 层_naomi) 
								{
									若 (标记_泡 == 0) 
									{
										标记_泡 = 1;
										图层_up做wn(键_窗,   1);
										// 图层_slide(层_泡, 层_naomi->vx0 - 80, 层_naomi->vy0 - 30);
										图层_up做wn(层_泡, 层管->顶 - 1);
										
										// 打印字体_美互标码_层((无符号 整型 *)层_背层, 100,300, 0xFFFFFF,0x000000,".epm 文件 循环mat 错误or.\n", 0); 
											// 图层_刷新(层_背层, 0, 0, 层_背层->b横坐标大小, 层_背层->b纵坐标大小);
										///////////////////
										// show颜色();
										结构 控制台 控制台;
	// 结构 内存管理 *内存管理 = (结构 内存管理 *) 内存管理_地址;
		// 整型 *文件分配表 = (整型 *) 内存管理_分配_4096(内存管理, 4 * 2880);
		// 字符 *命令行xx = (字符 *) 内存管理_分配_4096(内存管理, 10*10);
// 命令行xx[0]='n';
	// 命令行xx[1]='c';
	// 命令行xx[2]='s';
	// 命令行xx[3]='t';
	// 命令行xx[4]=' ';
	// 命令行xx[5]='i';
	// 命令行xx[6]='n';
	// 命令行xx[7]='v';
	// 命令行xx[8]='a';
	// 命令行xx[9]='d';
	// 命令行xx[10]='e';
	// 命令行xx[11]='r';
	// 命令行xx[12]='.';
	// 命令行xx[13]='e';
	// 命令行xx[14]='p';
	// 命令行xx[15]='m'; 
										 cmd_ncst(&控制台, "ncst 输入vader.epm",内存总计);
										//////////////////
									}
									若 (标记_泡 == 2) 
									{
										标记_泡 = 3;
										图层_up做wn(键_窗,   -1);
										图层_up做wn(层_泡, -1);
									}
								}
							}
							若 ((层->旗帜 & 0xf00) == 0x200) 
							{
								/* 窗口被最小化 */
								标记_鼠标 |= 0x0130;
							}
							若 ((层->旗帜 & 0xf00) == 0) 
							{
								/* 像窗户一样 */
								图层_up做wn(层, 层管->顶 - 2);
								若 (层 != 键_窗 && 层 != 0) 
								{
									键窗_关闭(键_窗);
									键_窗 = 层;
									键窗_打开(键_窗);
								}
								/* 一般窗口 */
								若 (3 <= x && x < 层->b横坐标大小 - 3 && 3 <= y && y < 21) 
								{
									mmx = mx;	/* 到窗口移动模式 */
									mmy = my;
									mmx2 = 层->vx0;
									new_wy = 层->vy0;
								}
								若 (5 <= y && y < 19) 
								{
									若 (层->b横坐标大小 - 20 <= x && x < 层->b横坐标大小 - 5) 
									{
										/* [X]按键 */
										标记_鼠标 |= 0x0110;
									}
									若 (层->b横坐标大小 - 31 <= x && x < 层->b横坐标大小 - 21) 
									{
										/* [_]按键 */
										标记_鼠标 |= 0x0120;
									}
								}
							}
						} 
						则 
						{
							若 ((标记_鼠标 & 0x0f00) == 0) 
							{
								x = mx - mmx;	/* 移动计算 */
								y = my - mmy;
								/* 我没有按下按键等。 */
								/* 窗口移动模式 */
								new_wx = (mmx2 + x + 2) & ~3;
								new_wy = new_wy + y;
								mmy = my;		/* 移动后更新坐标 */
							}
						}
					} 
					则 若 (鼠解码.按钮 & 0x02) 
					{
						/* 右键单击 */
						标记_鼠标 |= 0x02;
						若 (mmx < 0) 
						{
							若 (层 == 层_naomi || (层->旗帜 & 0x200) != 0) 
							{
								mmx = mx;	/* 要移动模式 */
								mmy = my;
								mmx2 = 层->vx0;
								new_wy = 层->vy0;
							}
						} 
						则 
						{
							若 ((标记_鼠标 & 0x0f00) == 0) 
							{
								x = mx - mmx;	/* 移动计算 */
								y = my - mmy;
								/* 我没有按下按键等。 */
								/* 窗口移动模式 */
								new_wx = (mmx2 + x + 2) & ~3;
								new_wy = new_wy + y;
								mmy = my;		/* 移动后更新坐标 */
							}
						}
					} 
					则 若 (鼠解码.按钮 == 0) 
					{
						/* 什么都没有 */
						若 (标记_鼠标 & 0x01) 
						{
							/* 左终止 */
							若 ((标记_鼠标 & 0x0f00) == 0x0100 && 5 <= y && y < 19) 
							{
								/* 窗户围栏 */
								若 ((标记_鼠标 & 0xf0) == 0x10 && 层->b横坐标大小 - 20 <= x && x < 层->b横坐标大小 - 5) 
								{
									/* 窗口关闭 */
									任务 = 层->任务;
									若 ((层->旗帜 & 0x10) != 0) 
									{
										/* 是应用程序制作的窗口吗？ */
										任务->语言模式 = 任务->语言模式0;	/* 撤消API更改的语言模式 */
										旧语言 = 任务_a->语言模式;		/* 暂时将task_a字模式与任务匹配 */
										任务_a->语言模式 = 任务->语言模式;
										控制台_打印字符0(任务->控制台, "\n终止(鼠标) :\n");
										任务_a->语言模式 = 旧语言;
										出入流_禁中断();
										任务->tss.e加基 = (整型) &(任务->tss.esp0);
										任务->tss.eip = (整型) 甲语言_结束_应用;
										出入流_许中断();
										任务_运行(任务, -1, 0);
									} 
									则 
									{
										/* 控制台 */
										图层_up做wn(层, -1);	/* 隐藏现在 */
										键窗_关闭(键_窗);
										键_窗 = 0;
										若 (层管->顶 > 2) 
										{
											键_窗 = 层管->图层s[层管->顶 - 2];
											键窗_打开(键_窗);
										}
									}
								}
								若 ((标记_鼠标 & 0xf0) == 0x20 && 层->b横坐标大小 - 31 <= x && x < 层->b横坐标大小 - 21) 
								{
									/* [_]按键点击 */
									图层_up做wn(层, -100);	/* 隐藏 */
									键窗_关闭(键_窗);
									键_窗 = 0;
									层2 = 打开_奥米(层管, 内存总计, 层);
									图层_slide(层2, 层->vx0 + 层->b横坐标大小 - 45, 层->vy0);
									若 (层管->顶 > 2) 
									{
										键_窗 = 层管->图层s[层管->顶 - 2];
										键窗_打开(键_窗);
									}
									图层_up做wn(层2, 1);
									循环(j = 0; j < M加基_M输入ID; j++) 
									{
										若 (小列表[j] < 0) 
										{
											小列表[j] = 1;		/* m输入_id使用中 */
											层2->m输入_id = j;	/* 匹配标签？ */
											层->m输入_id = j;
											终止;
										}
									}
								}
								若 ((标记_鼠标 & 0xf0) == 0x30) 
								{
									/* 点击Omelette Naomi */
									键窗_关闭(键_窗);
									循环 (j = 0; j < M加基_图层S; j++) 
									{
										键_窗 = &层管->图层s0[j];
										若 (键_窗->高 < 0) 
										{
											若 (键_窗->m输入_id == 层->m输入_id) 
											{
												小列表[层->m输入_id] = -1;
												层->m输入_id = -1;
												键_窗->m输入_id = -1;
												图层_空余(层);
												图层_slide(键_窗, 层->vx0 - 键_窗->b横坐标大小 + 42, 层->vy0);
												图层_up做wn(键_窗, 层管->顶 - 1);
												键窗_打开(键_窗);
												终止;
											}
										}
									}
								}
							}
							/* Naomi-san或开始菜单 */
							若 (标记_泡 == 1) 
							{
								标记_泡 = 2;
							} 则 若 (标记_泡 == 3) 
							{
								标记_泡 = 0;
							}
						} 则 若 (标记_鼠标 & 0x02) 
						{
							/* 右终止 */
						}
						标记_鼠标 = 0;
						mmx = -1;	/* 正常模式 */
						若 (new_wx != 0x7fffffff) 
						{ 
							图层_slide(层, new_wx, new_wy);	/* 确认一次 */
							new_wx = 0x7fffffff;
						}
					}
				}
			} 
			则 若 (768 <= i && i < 1024) 
			{
				关闭_控制台(层管->图层s0 + (i - 768));
			} 
			则 若 (1024 <= i && i < 2024) 
			{
				关闭_控制台任务(任务ctl->任务s0 + (i - 1024));
			} 
			则 若 (2024 <= i && i < 2280) 
			{
				/* 仅关闭控制台 */
				层2 = 层管->图层s0 + (i - 2024);
				内存管理_空余_4096(内存管理, (整型) 层2->缓存, 256 * 165);
				图层_空余(层2);
			} 
			则 若 (i == 0x4000) 
			{
				/* 键_窗変更要求 from api.乙 */
				键_窗 = 层管->图层s[层管->顶 - 2];
			} 
			则 若 (i == 0x4001) 
			{
				/* 座标标准码更新请求来自api。乙-0x400a */
				mx = 层_鼠标->vx0;
				my = 层_鼠标->vy0;
			}
		}
	}
}


空 任务_乙_入口(结构 图层 *层_窗_b)
{
	结构 先进先出32 先进先出;
	结构 定时器 *定时器_1秒;
	整型 i, 先进先出缓存[128], 计数 = 0, 计数0 = 0;
	字符 s[12];

	先进先出32_初始化(&先进先出, 128, 先进先出缓存, 0);
	定时器_1秒 = 定时器_分配();
	定时器_初始化(定时器_1秒, &先进先出, 100);
	定时器_设置时间(定时器_1秒, 100);

	循环 (;;) {
		计数++;
		出入流_禁中断();
		若 (先进先出32_状态(&先进先出) == 0) {
			出入流_许中断();
		} 则 {
			i = 先进先出32_获取(&先进先出);
			出入流_许中断();
			若 (i == 100) {
				图层_刷新(层_窗_b, 0, 0, 层_窗_b->b横坐标大小, 层_窗_b->b纵坐标大小);
				spr整型f(s, "%11d", 计数 - 计数0);
				打印字体_美互标码_层(层_窗_b, 24, 28, 0x000000, 0xffffff, s, 0);
				
				计数0 = 计数;
				定时器_设置时间(定时器_1秒, 100);
				
			}
		}
	}
}
空 系统时钟_任务(空)
{结构 启动信息 *启信 = (结构 启动信息 *) 地址_启动信息;
	整型 i, j;
	字符 错误, cnt;
	无符号 字符 s[6];
	静态 无符号 字符 adr[7] = { 0x00, 0x02, 0x04, 0x07, 0x08, 0x09, 0x32 };
	静态 无符号 字符 m加基[7] = { 0x60, 0x59, 0x23, 0x31, 0x12, 0x99, 0x99 };
	结构 任务 *任务 = 任务_当前();
	结构 定时器 *时钟_定时器 = 定时器_分配();
	定时器_初始化(时钟_定时器, &任务->先进先出, 1);
	定时器_设置时间(时钟_定时器, 100);
	无符号 字符 t[7];
	循环 (;;) {
		出入流_禁中断();
		若 (先进先出32_状态(&任务->先进先出) == 0) 
		{
			任务_睡眠(任务);
			出入流_许中断();
		} 
		则 
		{
			i = 先进先出32_获取(&任务->先进先出);
			出入流_许中断();
			若 (i == 1) {
				循环(cnt = 0; cnt < 3; cnt++)
				{
					错误 = 0;
					循环 (j = 0; j < 7; j++) 
					{
						出入流_输出8(0x70, adr[j]);
						t[j] = 出入流_输入8(0x71);
					}
					循环 (j = 0; j < 7; j++) 
					{
						出入流_输出8(0x70, adr[j]);
						若 (t[j] != 出入流_输入8(0x71) || (t[j] & 0x0f) > 9 || t[j] > m加基[j]) 
						{
							错误 = 1;
						}
					}
					若 (错误 == 0) 
					{
						终止;
					}
				}
				结构 层管管理 *ctl = (结构 层管管理 *) *((整型 *) 0x0fe4);
				结构 图层 *层 = &ctl->图层s0[1];
				spr整型f(s, "%02X:%02X\0", t[2], t[1]);
				打印字体_美互标码_层((无符号 整型 *)层,启信->屏幕横坐标-60,7, 0xffffff, 0x7A8A9D,s, 5);
	// 图层_刷新(层, 0, 0, 层->b横坐标大小, 层->b纵坐标大小);
								   
				定时器_设置时间(时钟_定时器, 100);
			}
		}
	}
}
空 任务_时间_入口(结构 图层 *层_时间)
{
	结构 启动信息 *启信 = (结构 启动信息 *) 地址_启动信息;
	结构 先进先出32 先进先出;
	结构 定时器 *定时器_1秒;
	整型 i, 先进先出缓存[128], 计数 = 0, 计数0 = 0;
	字符 s[12];

	先进先出32_初始化(&先进先出, 128, 先进先出缓存, 0);
	定时器_1秒 = 定时器_分配();
	定时器_初始化(定时器_1秒, &先进先出, 100);
	定时器_设置时间(定时器_1秒, 100);

	循环 (;;) {
		计数++;
		出入流_禁中断();
		若 (先进先出32_状态(&先进先出) == 0) {
			出入流_许中断();
		} 则 {
			i = 先进先出32_获取(&先进先出);
			出入流_许中断();
			若 (i == 100) {
				整型 ix, t[3];
	字符 sx[5];
	循环 (ix = 0; ix < 3; ix++) 
	{
		t[ix] = 实时时钟_获取(ix+3);
	}
	// spr整型f(sx, "%02d:%02d:%02d\n",  t[0], t[1],t[2]);
	 spr整型f(sx, "%02d:%02d\n",  t[0], t[1] );
	打印字体_美互标码_层((无符号 整型 *)层_时间,启信->屏幕横坐标-60,7, 0xffffff, 0x7A8A9D,sx, 5);
	图层_刷新(层_时间, 0, 0, 层_时间->b横坐标大小, 层_时间->b纵坐标大小);
				定时器_设置时间(定时器_1秒, 6000);
				
			}
		}
	}
	
	
	// 整型 ix, t[3];
	// 字符 sx[5];
	// 循环 (ix = 0; ix < 3; ix++) 
	// {
		// t[ix] = 实时时钟_获取(ix+3);
	// }
	// spr整型f(sx, "%02d:%02d:%02d\n",  t[0], t[1],t[2]);
	 
	// 打印字体_美互标码_层((无符号 整型 *)层_时间,90,7, 0xffffff, 0x7A8A9D,sx, 1);
	// 图层_刷新(层_时间, 0, 0, 层_时间->b横坐标大小, 层_时间->b纵坐标大小);
}




空 show颜色33()
{
	结构 控制台 控制台;
	结构 内存管理 *内存管理 = (结构 内存管理 *) 内存管理_地址;
		整型 *文件分配表 = (整型 *) 内存管理_分配_4096(内存管理, 4 * 2880);
		字符 *命令行xx = (字符 *) 内存管理_分配_4096(内存管理, 10*10);
	命令行xx[0]='i';
	命令行xx[1]='n';
	命令行xx[2]='v';
	命令行xx[3]='a';
	命令行xx[4]='d';
	命令行xx[5]='e';
	命令行xx[6]='r';
	命令行xx[7]='.';
	命令行xx[8]='e';
	命令行xx[9]='p';
	命令行xx[10]='m'; 
	  cmd_应用(&控制台,文件分配表,命令行xx);
	  返回;
}
空 show颜色()
{
	 
结构 内存管理 *内存管理 = (结构 内存管理 *) 内存管理_地址;
	整型 *文件分配表 = (整型 *) 内存管理_分配_4096(内存管理, 4 * 2880);
	文件_读取文件(文件分配表, (无符号 字符 *) (地址_磁盘镜像 + 0x000200));
	结构 文件信息 *文信;
	结构 层管管理 *层管;
	结构 图层 *层;
	字符 名称[18], *p, *q;
	结构 任务 *任务 = 任务_当前();
	整型 i;
	整型 段大小, 数据大小, esp, dathrb, 应用大小;

	任务->语言模式0 = 任务->语言模式;
	字符 *命令行xx = (字符 *) 内存管理_分配_4096(内存管理, 10*10);
	命令行xx[0]='c';
	命令行xx[1]='o';
	命令行xx[2]='l';
	命令行xx[3]='o';
	命令行xx[4]='r';
	命令行xx[5]='.';
	命令行xx[6]='e';
	命令行xx[7]='p';
	命令行xx[8]='m'; 
/* 从命令行生成文件名 */
	// 循环 (i = 0; i < 13; i++) {
		// 若 (命令行xx[i] <= ' ')
			// 终止;
		// 名称[i] = 命令行xx[i];
	// }
	// 名称[i] = 0;
 
	文信 = 文件_搜索("输入vader.epm", (结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
	// 若 (文信 == 0 && 名称[i - 1] != '.') {
		// /* 找不到，用EPM重试 */
		// 名称[i    ] = '.';
		// 名称[i + 1] = 'e';
		// 名称[i + 2] = 'p';
		// 名称[i + 3] = 'm';
		// 名称[i + 4] = 0;
		// 文信 = 文件_搜索(命令行xx, (结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
	// }
	// 若 (文信 == 0) {
		// /* 仍然不合理 */
		// // 返回 0;
	// }

	/* 有一个档案 */
	应用大小 = 文信->大小;
	p = 文件_加载文件2(文信->clustno, &应用大小, 文件分配表);
	// 若 (应用大小 >= 36 && strncmp(p + 4, "Hari", 4) == 0 && *p == 0x00) {
		段大小 = *((整型 *) (p + 0x0000));
		esp     = *((整型 *) (p + 0x000c));
		数据大小 = *((整型 *) (p + 0x0010));
		dathrb  = *((整型 *) (p + 0x0014));
		q = (字符 *) 内存管理_分配_4096(内存管理, 段大小);
		任务->ds_基础 = (整型) q;
		设置_分段描述(任务->ldt + 0, 应用大小 - 1, (整型) p, AR_代码32_ER + 0x60);
		设置_分段描述(任务->ldt + 1, 段大小 - 1, (整型) q, AR_数据32_RW + 0x60);
		循环 (i = 0; i < 数据大小; i++)
			q[esp + i] = p[dathrb + i];
		开始_应用(0x1b, 0 * 8 + 4, esp, 1 * 8 + 4, &(任务->tss.esp0));
		层管 = (结构 层管管理 *) *((整型 *) 0x0fe4);
		循环 (i = 0; i < M加基_图层S; i++) 
		{
			层 = &(层管->图层s0[i]);
			若 ((层->旗帜 & 0x11) == 0x11 && 层->旗帜 && 层->任务 == 任务) 
			{
				/* 应用程序结束了，但仍有一个底层 */
				图层_空余(层);		/* 关闭 */
			}
		}
		循环 (i = 0; i < 8; i++) 
		{
			/* 关闭未关闭的文件 */
			若 (任务->f句柄[i].缓存 != 0) 
			{
				内存管理_空余_4096(内存管理, (整型) 任务->f句柄[i].缓存, 任务->f句柄[i].大小);
				任务->f句柄[i].缓存 = 0;
			}
		}
		任务->语言模式 = 任务->语言模式0;		// 撤消API更改的语言模式
		定时器_取消所有(&任务->先进先出);
		内存管理_空余_4096(内存管理, (整型) q, 段大小);
		任务->语言字节 = 0;
	// } 则 {
		// 打印字体_美互标码_层((无符号 整型 *)层_背层, 100,300, 0xFFFFFF,0x000000,".epm 文件 循环mat 错误or.\n", 0); 
		// // 控制台_打印字符0(控制台, ".epm 文件 循环mat 错误or.\n");
	// }
	内存管理_空余_4096(内存管理, (整型) p, 应用大小); 
}

空 键窗_关闭(结构 图层 *键_窗)
{
	改变_窗口标题(键_窗, 0);
	若 ((键_窗->旗帜 & 0x20) != 0) 
	{
		先进先出32_放入(&键_窗->任务->先进先出, 3);	/* 控制台光标关闭*/
	}
	返回;
}

空 键窗_打开(结构 图层 *键_窗)
{
	改变_窗口标题(键_窗, 1);
	若 ((键_窗->旗帜 & 0x20) != 0) 
	{
		先进先出32_放入(&键_窗->任务->先进先出, 2);	/* 控制台光标打开 */
	}
	返回;
}

结构 任务 *打开_控制台任务(结构 图层 *层, 无符号 整型 内存总计)
{
	结构 内存管理 *内存管理 = (结构 内存管理 *) 内存管理_地址;
	结构 任务 *任务 = 任务_分配();
	整型 *控制台_先进先出 = (整型 *) 内存管理_分配_4096(内存管理, 128 * 4);
	任务->控制台_堆 = 内存管理_分配_4096(内存管理, 64 * 1024);
	任务->tss.esp = 任务->控制台_堆 + 64 * 1024 - 12;
	任务->tss.eip = (整型) &控制台_任务;
	任务->tss.es = 1 * 8;
	任务->tss.乙s = 2 * 8;
	任务->tss.ss = 1 * 8;
	任务->tss.ds = 1 * 8;
	任务->tss.fs = 1 * 8;
	任务->tss.gs = 1 * 8;
	*((整型 *) (任务->tss.esp + 4)) = (整型) 层;
	*((整型 *) (任务->tss.esp + 8)) = 内存总计;
	任务_运行(任务, 2, 2);
	先进先出32_初始化(&任务->先进先出, 128, 控制台_先进先出, 任务);
	返回 任务;
}

结构 图层 *打开_控制台(结构 层管管理 *层管, 无符号 整型 内存总计)
{
/* 旧 窗体 大小 : 256 * 165 (文本框 : 240, 128) */
	结构 内存管理 *内存管理 = (结构 内存管理 *) 内存管理_地址;
	结构 图层 *层 = 图层_分配(层管);
	整型 bpp = 获取_bpp();
	无符号 字符 *缓存 = (无符号 字符 *) 内存管理_分配_4096(内存管理, (控制台_大小X + 16) * (控制台_大小Y + 37) * (bpp >> 3));
	图层_设置缓存(层, 缓存, 控制台_大小X + 16, 控制台_大小Y + 37, -1);	/* 没有透明的颜色 */
	制作_窗体((无符号 整型 *) 缓存, 控制台_大小X + 16, 控制台_大小Y + 37, "控制台", 0 , 0);
	制作_文本框(层, 8, 28, 控制台_大小X, 控制台_大小Y, 0x000000);
	层->任务 = 打开_控制台任务(层, 内存总计);
	层->旗帜 |= 0x20;	/* 用光标 */
	返回 层;
}

结构 图层 *打开_奥米(结构 层管管理 *层管, 无符号 整型 内存总计, 结构 图层 *旧层)
{
	结构 内存管理 *内存管理 = (结构 内存管理 *) 内存管理_地址;
	结构 图层 *层 = 图层_分配(层管);
	整型 bpp = 获取_bpp();
	无符号 字符 *缓存;

	缓存 = (无符号 字符 *) 内存管理_分配_4096(内存管理, 31 * 16 * (bpp >> 3));
	图层_设置缓存(层, 缓存, 31, 16, 99);
	制作_奥米(层, 0, 0);
	层->旗帜 |= 0x0200;
	返回 层;
}

空 关闭_控制台任务(结构 任务 *任务)
{
	结构 内存管理 *内存管理 = (结构 内存管理 *) 内存管理_地址;
	任务_睡眠(任务);
	内存管理_空余_4096(内存管理, 任务->控制台_堆, 64 * 1024);
	内存管理_空余_4096(内存管理, (整型) 任务->先进先出.缓存, 128 * 4);
	任务->旗帜 = 0;	/* 任务_空余(任务);而不是 */
	
}

空 关闭_控制台(结构 图层 *层)
{
	结构 内存管理 *内存管理 = (结构 内存管理 *) 内存管理_地址;
	结构 任务 *任务 = 层->任务;
	内存管理_空余_4096(内存管理, (整型) 层->缓存, 256 * 165);
	图层_空余(层);
	关闭_控制台任务(任务);
	返回;
}

结构 图层 *搜索_图层(结构 层管管理 *层管, 整型 mx, 整型 my)
{
	结构 图层 *层 = 0;
	整型 i, x, y;
	循环 (i = 层管->顶 - 1; i > 0; i--) 
	{
		层 = 层管->图层s[i];
		x = mx - 层->vx0;
		y = my - 层->vy0;
		若 (0 <= x && x < 层->b横坐标大小 && 0 <= y && y < 层->b纵坐标大小) 
		{
			若 (层->缓存[y * 层->b横坐标大小 + x] != 层->col_输入v) 
			{
				返回 层;
			}
		}
	}
	返回 0;
}
