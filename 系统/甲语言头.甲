; haribote-os boot asm
; tab=4

[命令模式 "i486p"]				; "想要使用486指令"的叙述

; 不指定相同数值
vbemode1	等换		0x117			; 第1种模式  16位
vbemode2	等换		0x105			; 第2种模式  8位       视频电子标准协会(简称VBE)

botpak	等换		0x00280000		; 主程序装入目标
dskcac	等换		0x00100000		; 磁盘buf位置
dskcac0	等换		0x00008000		; 磁盘buf位置（实模式）

; boot_info
cyls	等换		0x0ff0			; 设定启动区
leds	等换		0x0ff1
vmode	等换		0x0ff2			; 关于颜色数目的信息，颜色的位数
scrnx	等换		0x0ff4			; 分辨率的X（screen x）
scrny	等换		0x0ff6			; 分辨率的Y（screen y）
vram	等换		0x0ff8			; 图像buf区的开始地址

		载址		0xc200			; 这个程序将要被装载到内存的什么地方呢？

; 画面设定::有没有vbe
		传送		加寄,0x9000
		传送		附段寄,加寄
		传送		终寄,0
		传送		加寄,0x4f00
		中断 		0x10
		比较		加寄,0x004f
		不等转		scrn320

; 画面设定::vbe版本检查
		传送		加寄,[附段寄:终寄+4]
		比较		加寄,0x0200
		小于		scrn320

; 画面设定::获取有关视频电子标准协会模式指定的模式的信息
		传送		计寄,vbemode1				; 第一选项
scrn_retry:								; 第二选项
		传送		加寄,0x4f01
		中断		0x10
		比较		加寄,0x004f
		不等转		scrn_next				; 下一选项

; 画面设定::检查屏幕模式信息
		传送		加寄,[附段寄:终寄+0x00]			; 8bit, 16位 常见的检查项目
		与			加寄,0x0080
		等零转		scrn_next
		传送		加寄,计寄
		与			加寄,0x0010				; 检查是否为8位颜色或16位颜色
		比较		加寄,0x0010
		等零		scrn_16bit				; 如果是16位则跳转
		传送		dl,8					;  8位屏幕模式检查
		比较		字节 [附段寄:终寄+0x19],8
		不等转		scrn_next
		比较		字节 [附段寄:终寄+0x1b],4
		不等转		scrn_next

; 画面设定::模式切换
scrn_设置:
		加法		计寄,0x4000
		传送		bx,计寄					;	传送		bx,vbemode1+0x4000
		减法		计寄,0x4000
		传送		加寄,0x4f02
		中断		0x10
		传送		字节 [vmode],dl			;记下屏幕模式（由乙语言引用）
		传送		加寄,[附段寄:终寄+0x12]
		传送		[scrnx],加寄
		传送		加寄,[附段寄:终寄+0x14]
		传送		[scrny],加寄
		传送		扩加寄,[附段寄:终寄 +0x28]
		传送		[vram],扩加寄
		跳转		键status

; 切换模式
scrn_next:
		比较		计寄,vbemode1				; 到了第二次
		等零		scrn_next1to2
		比较		计寄,vbemode2				; 由于第二次不可能，请转到分辨率320
		等零		scrn320
scrn_next1to2:
		传送		计寄,vbemode2
		跳转		scrn_retry

; 16位屏幕模式检查
scrn_16bit:
		传送		dl,16
		比较		字节 [附段寄:终寄+0x19],16
		不等转		scrn_next
		比较		字节 [附段寄:终寄+0x1b],6
		不等转		scrn_next
		跳转		scrn_设置

; 画面设定::无法使用视频电子标准协会模式指定的模式。
scrn320:
		传送		加低,0x13					;vga图形，320x200x8bit颜色
		传送		加高,0x00
		中断		0x10
		传送		字节 [vmode],8			; 记录画面模式（参考乙语言）
		传送		字 [scrnx],320
		传送		字 [scrny],200
		传送		双字 [vram],0x000a0000

; 用 基本输入输出系统 (Bios)取得键盘上各种LED指示灯的状态
键status:
		传送		加高,0x02
		中断		0x16 			; 键board bios
		传送		[leds],加低

;防止片接受任何中断
;在兼容机的规格中，如果要初始化类似片，
;如果您在暂停之前不这样做，您偶尔会挂起
;片初始化将在稍后完成

		传送		加低,0xff
		输出		0x21,加低
		空操作						; 输出命令因为如果继续，似乎有一个模型不起作用
		输出		0xa1,加低

		禁中断						; 此外，即使在cpu级别也禁止中断。

; 为了让CPU能够访问1MB以上的内存空间，设定 A20GATE

		调用		waitkbdout
		传送		加低,0xd1
		输出		0x64,加低
		调用		waitkbdout
		传送		加低,0xdf			; enable a20
		输出		0x60,加低
		调用		waitkbdout

; 切换到保护模式


		全局表		[gdtr0]			; 设定临时GDT
		传送		扩加寄,控寄0
		与			扩加寄,0x7fffffff	; 设bit31为0 （为了禁止颁）
		或			扩加寄,0x00000001	; 设bit0为1 （为了切换到保护模式）
		传送		控寄0,扩加寄
		跳转		pipelineflash
pipelineflash:
		传送		加寄,1*8			;  可读写的段32bit
		传送		数段寄,加寄
		传送		附段寄,加寄
		传送		标段寄,加寄
		传送		全段寄,加寄
		传送		栈段寄,加寄

; bootpack的转送

		传送		扩源寄,主程序	; 转送源	
		传送		扩终寄,botpak		; 转送目的地
		传送		扩计寄,512*1024/4
		调用		memcpy

;磁盘数据最终转送到它本来的位置去
;首先从启动扇区开始

		传送		扩源寄,0x7c00		; 转送源
		传送		扩终寄,dskcac		; 转送目的地
		传送		扩计寄,512/4
		调用		memcpy

; 所有剩下的

		传送		扩源寄,dskcac0+512	; 转送源
		传送		扩终寄,dskcac+512	; 转送目的地
		传送		扩计寄,0
		传送		cl,字节 [cyls]
		乘法		扩计寄,512*18*2/4	; 从柱面数字变换为字节数/4
		减法		扩计寄,512/4		; 减去 IPL
		调用		memcpy

; 必须由asm头来完成的工作，至此全部完毕
; 以后就交由bootpack来完成
	
; 主程序的启动

		传送		扩基寄,botpak
		传送		扩计寄,[扩基寄+16]
		加法		扩计寄,3			; 扩计寄 += 3;
		右移		扩计寄,2			; 扩计寄 /= 4;
		等零转		skip			; 没有要转送的东西时
		传送		扩源寄,[扩基寄+20]	; 转送源
		加法		扩源寄,扩基寄
		传送		扩终寄,[扩基寄+12]	; 转送目的地
		调用		memcpy
skip:
		传送		扩栈寄,[扩基寄+12]	; 栈初始值
		跳转		双字 2*8:0x0000001b

waitkbdout:
		输入		 加低,0x64
		与		 	加低,0x02
		不等零		waitkbdout		; AND的结果如果不是0，就跳到waitkbdout
		返回

memcpy:
		传送		扩加寄,[扩源寄]
		加法		扩源寄,4
		传送		[扩终寄],扩加寄
		加法		扩终寄,4
		减法		扩计寄,1
		不等零		memcpy			; 减法运算的结果如果不是0，就跳转到memcpy
		返回
; 复制内存如果不忘记地址大小前缀，可以使用字符串命令编写

		字节对齐	16
gdt0:
		预约字节	8				; NULL selector
		定字		0xffff,0x0000,0x9200,0x00cf	;可以读写的段 （segment） 32bit
		定字		0xffff,0x0000,0x9a28,0x0047	;可以执行的段 （segment） 32bit (bootpack用)

		定字		0
gdtr0:
		定字		8*3-1
		定双字		gdt0

		字节对齐	16
主程序:
