/* 定时器相关的 */
/* 作者：邵世雄 */

#引入 "主程序.头"

#定义 PIT_CTRL	0x0043
#定义 PIT_CNT0	0x0040

结构 定时器管理 定管;

#定义 定时器_标识_ALLOC	1	/* 已配置状态 */
#定义 定时器_标识_USING	2	/* 定时器运行中 */
空 初始化_pit(空)
{
	/* PIT初始化 */
	出入流_out8(PIT_CTRL, 0x34);
	出入流_out8(PIT_CNT0, 0x9c);
	出入流_out8(PIT_CNT0, 0x2e);

	定管.计数 = 0;
	定管.下一个 = 0xffffffff; /* 因为只有哨兵，所以下一个超时时刻就是哨兵的时刻 */
	返回;
}

空 初始化_定管(空)
{
    结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
    整型 i;
    结构 定时器 *t;
    定管.定时s0 = (结构 定时器 *) 内管_分配_4k(内管, 最大值_定时器 * 占字数(结构 定时器));
    循环 (i = 0; i < 最大值_定时器; i++) {
        定管.定时s0[i].标记 = 0; /* 未使用 */
    }
	t = 定时_分配();	/* 1制作 */
	t->超时 = 0xffffffff;
	t->标记 = 定时器_标识_USING;
	t->下一个 = 0;	/* 最后一个  */
	定管.t0 = t;	/* 虽然它是一个最终的，但它是一个开始。 所谓单独的 */
    返回;
}

结构 定时器 *定时_分配(空)
{
	整型 i;
	循环(i = 0; i < 最大值_定时器; i++) {
		若 (定管.定时s0[i].标记 == 0) {
			定管.定时s0[i].标记  = 定时器_标识_ALLOC;	/* 未使用 */
			定管.定时s0[i].标记2 = 0;
			返回 &定管.定时s0[i];
		}
	}
	返回 0;	/* 找不到 */
}

空 定时_可用(结构 定时器 *定时)
{
	定时->标记 = 0;	/* 未使用 */
	返回;
}

空 定时_初始化(结构 定时器 *定时, 结构 先进先出32 *进出, 整型 数据)
{
	定时->进出 = 进出;
	定时->数据 = 数据;
	返回;
}

空 定时_设置时间(结构 定时器 *定时, 无符号 整型 超时)
{
	整型 e;
	结构 定时器 *t, *s;

	定时->超时 = 超时 + 定管.计数;
	定时->标记 = 定时器_标识_USING;	/* 使用中 */

	e = 出入流_加载_e标记s();
	出入流_cli();

	t = 定管.t0;
	若 (定时->超时 <= t->超时) {
		/* 插入最前面的情况 */
		定管.t0 = 定时;
		定时->下一个 = t;	/* 下面是设定t */
		定管.下一个 = 定时->超时;
		转到 fin;
	}

/* 搜寻插入的位置 */
	循环 (;;) {
		s = t;
		t = t->下一个;
		若 (定时->超时 <= t->超时) {
			s->下一个 = 定时;
			定时->下一个 = t;
			转到 fin;
		}
	}

fin:
	出入流_store_e标记s(e);
	返回;
}

整型 定时_取消(结构 定时器 *定时)
{
	整型 e;
	结构 定时器 *t;
	e = 出入流_加载_e标记s();
	出入流_cli();	/* 在安装过程中防止计时器更改 */
	若 (定时->标记 == 定时器_标识_USING) {
		/* 是否有必要取消计时器？ */
		若 (定时 == 定管.t0) {
			/* 当它是第一个时取消处理 */
			t = 定时->下一个;
			定管.t0 = t;
			定管.下一个 = t->超时;
		} 则 {
			/* 取消开头以外的处理 */
			/* 找到以前的计时器 */
			t = 定管.t0;
			循环 (;;) {
				若 (t->下一个 == 定时) {
					终止;
				}
				t = t->下一个;
			}
			t->下一个 = 定时->下一个;	/* 确保“计时器旁边”位于“计时器旁边”旁边*/
		}
		定时->标记 = 定时器_标识_ALLOC;
		出入流_store_e标记s(e);
		返回 1;	/*成功取消流程*/
	}
	出入流_store_e标记s(e);
	返回 0;		/* 取消处理失败 */
}

空 定时_取消所有(结构 先进先出32 *进出)
{
	整型 e, i;
	结构 定时器 *t;
	e = 出入流_加载_e标记s();
	出入流_cli();	/* 在安装过程中防止计时器更改 */
	循环 (i = 0; i < 最大值_定时器; i++) 
	{
		t = &定管.定时s0[i];
		若 (t->标记 != 0 && t->标记2 != 0 && t->进出 == 进出) 
		{
			定时_取消(t);
			定时_可用(t);
		}
	}
	出入流_store_e标记s(e);
	返回;
}

空 inthandler20(整型 *esp)
{
	结构 定时器 *定时;
	字符 ts = 0;

	出入流_out8(PIC0_OCW2, 0x60);	/* 把IRQ-00信号接收完了的信息通知给PIC */
	定管.计数++;
	若 (定管.下一个 > 定管.计数)
		返回;
	定时 = 定管.t0;	/* 首先把最前面的地址赋给定时 */

	循环 (;;) 
	{
		若 (定时->超时 > 定管.计数)
			终止;/* 因为定时s的定时器都处于运行状态，所以不确认标记 */
		/* 超时 */
		定时->标记 = 定时器_标识_ALLOC;
		若 (定时 != 任_定时)
			进出32_放入(定时->进出, 定时->数据);
		则
			ts = 1; /* 任_定时超时 */
		定时 = 定时->下一个; /* 将下一定时器的地址代入定时 */		
	}

	定管.t0 = 定时;	/* 新位移 */
	定管.下一个 = 定管.t0->超时;/* 定管.下一个的设定 */

	若 (ts)
		任_切换();

	返回;
}
