/* 图层相关的  */
/* 作者 : 邵世雄 */
#引入 "主程序.头"

#定义 图层_使用	1

结构 图层管理 *层管_初始化(结构 内存管理 *内管, 无符号 字符 *显存, 整型 x大小, 整型 y大小)
{
	结构 图层管理 *层管;
	整型 i;

	层管 = (结构 图层管理 *) 内管_分配_4k(内管, 占字数 (结构 图层管理));
	若 (层管 == 0)
		转到 错;
	层管->网格 = (无符号 字符 *) 内管_分配_4k(内管, x大小 * y大小);
	若 (层管->网格 == 0) 
	{
		内管_可用_4k(内管, (整型) 层管, 占字数 (结构 图层管理));
		转到 错;
	}
	层管->显存  = 显存 ;
	层管->x大小 = x大小;
	层管->y大小 = y大小;
	层管->顶   = -1  ; /*一个图层都没有*/
	循环 (i = 0; i < 最大值_图层S; i++) 
	{
		层管->图层s0[i].标记 = 0;	/* 标记为未使用 */
		层管->图层s0[i].层管 = 层管;	/* 记录所属 */
	}
错:
	返回 层管;
}

结构 图层 *图层_分配(结构 图层管理 *层管)
{
	结构 图层 *层;
	整型 i;
	循环 (i = 0; i < 最大值_图层S; i++) 
	{
		若 (层管->图层s0[i].标记 == 0) 
		{
			层 = &层管->图层s0[i];
			层->标记 = 图层_使用;	 /* 标记为正在使用 */
			层->高度 = -1; 		/* 隐藏 */
			层->任 = 0;			/* 不要自动使用相关功能 */
			层->min_id = -1;
			返回 层;
		}
	}
	返回 0; /* 所有的图层都处于正在使用状态 */
}

空 图层_设置buf(结构 图层 *层, 无符号 字符 *buf, 整型 sx, 整型 sy, 整型 bgcol)
{
	层->buf     = buf;
	层->bx大小  = sx;
	层->by大小  = sy;
	层->col_inv = bgcol;
	返回;
}

空 图层_刷新网格(结构 图层管理 *层管, 整型 vx0, 整型 vy0, 整型 vx1, 整型 vy1, 整型 h0)
{
	整型 h, bx, by, vx, vy, bx0, by0, bx1, by1, sid4, *p;
	无符号 字符 *buf, sid, *网格 = 层管->网格;
	无符号 短整型 *buf16;
	无符号 整型 *buf24;
	结构 图层 *层;
	整型 bpp = 获取_bpp();

	/* 如果刷新范围在屏幕外，请更正 */
	若 (vx0 < 0) { vx0 = 0; }
	若 (vy0 < 0) { vy0 = 0; }
	若 (vx1 > 层管->x大小) { vx1 = 层管->x大小; }
	若 (vy1 > 层管->y大小) { vy1 = 层管->y大小; }

	循环 (h = h0; h <= 层管->顶; h++) 
	{
		层 = 层管->图层s[h];
		sid = 层 - 层管->图层s[0];
		buf = 层->buf;
		buf16 = (无符号 短整型 *) (层->buf);
		buf24 = (无符号 整型 *) (层->buf);

		/*vx0~vy1用于计算bx0~by1 */
		bx0 = vx0 - 层->vx0;
		by0 = vy0 - 层->vy0;
		bx1 = vx1 - 层->vx0;
		by1 = vy1 - 层->vy0;
		若 (bx0 < 0) { bx0 = 0; }
		若 (by0 < 0) { by0 = 0; }
		若 (bx1 > 层->bx大小) { bx1 = 层->bx大小; }
		若 (by1 > 层->by大小) { by1 = 层->by大小; }

		若 (层->col_inv == -1) 
		{
			若 ((层->vx0 & 3) == 0 && (bx0 & 3) == 0 && (bx1 & 3) == 0) 
			{
					/*高速ver（4字节类型），没有透明度*/
					bx1 = (bx1 - bx0) / 4;	/* MOV回数 */
					sid4 = sid | sid << 8 | sid << 16 | sid << 24;
					循环 (by = by0; by < by1; by++) 
					{
						vy = 层->vy0 + by;
						vx = 层->vx0 + bx0;
						p = (整型 *) &网格[vy * 层管->x大小 + vx];
						循环 (bx = 0; bx < bx1; bx++) 
						{
							p[bx] = sid4;
						}
					}
			} 
			则 
			{
				/* 没有透明度的高速版本（1字节类型） */
				循环 (by = by0; by < by1; by++) 
				{
					vy = 层->vy0 + by;
					循环 (bx = bx0; bx < bx1; bx++) {
						vx = 层->vx0 + bx;
						网格[vy * 层管->x大小 + vx] = sid;
					}
				}
			}
		} 
		则 
		{
			/* 普通版具有透明度 */
			若 (bpp == 8) 
			{
				循环 (by = by0; by < by1; by++) 
				{
					vy = 层->vy0 + by;
					循环 (bx = bx0; bx < bx1; bx++) 
					{
						vx = 层->vx0 + bx;
						若 (buf[by * 层->bx大小 + bx] != 层->col_inv)
							网格[vy * 层管->x大小 + vx] = sid;
					}
				}
			} 
			则 若 (bpp == 16) 
			{
				循环 (by = by0; by < by1; by++) 
				{
					vy = 层->vy0 + by;
					循环 (bx = bx0; bx < bx1; bx++) 
					{
						vx = 层->vx0 + bx;
						若 (buf16[by * 层->bx大小 + bx] != 层->col_inv)
							网格[vy * 层管->x大小 + vx] = sid;
					}
				}
			} 
			则 若 (bpp == 24) 
			{
				循环 (by = by0; by < by1; by++) 
				{
					vy = 层->vy0 + by;
					循环 (bx = bx0; bx < bx1; bx++) 
					{
						vx = 层->vx0 + bx;
						若 (buf24[by * 层->bx大小 + bx] != 层->col_inv)
							网格[vy * 层管->x大小 + vx] = sid;
					}
				}
			}
		}
	}
	返回;
}

空 图层_刷新sub(结构 图层管理 *层管, 整型 vx0, 整型 vy0, 整型 vx1, 整型 vy1, 整型 h0, 整型 h1)
{
	整型 h, bx, by, vx, vy, bx0, by0, bx1, by1;
	整型 bx2, sid4, i, i1, *p, *q, *r, j = 0;
	无符号 字符 sid, *网格 = 层管->网格;
	无符号 字符 *buf, *显存 = 层管->显存;
	无符号 短整型 *buf16, *显存16 = (无符号 短整型 *) (层管->显存);
	无符号 整型 *buf24, *显存24 = (无符号 整型 *) (层管->显存);
	结构 图层 *层;
	整型 bpp = 获取_bpp();

	/* 如果刷新范围在屏幕外，请更正 */
	若 (vx0 < 0) { vx0 = 0; }
	若 (vy0 < 0) { vy0 = 0; }
	若 (vx1 > 层管->x大小) { vx1 = 层管->x大小; }
	若 (vy1 > 层管->y大小) { vy1 = 层管->y大小; }

	循环 (h = h0; h <= h1; h++) 
	{
		层 = 层管->图层s[h];
		sid = 层 - 层管->图层s0;
		/*vx0~vy1用于计算bx0~by1 */
		bx0 = vx0 - 层->vx0;
		by0 = vy0 - 层->vy0;
		bx1 = vx1 - 层->vx0;
		by1 = vy1 - 层->vy0;
		若 (bx0 < 0) { bx0 = 0; }
		若 (by0 < 0) { by0 = 0; }
		若 (bx1 > 层->bx大小) { bx1 = 层->bx大小; }
		若 (by1 > 层->by大小) { by1 = 层->by大小; }
		若 (bpp == 8) 
		{
			buf = 层->buf;
			若 ((层->vx0 & 3) == 0) 
			{
				/* 4 byte 类型 */
				i  = (bx0 + 3) / 4;	/* bx0除以4（向上舍入） */
				i1 =  bx1      / 4;	/* bx1除以4（向下舍入） */
				i1 = i1 - i;
				sid4 = sid | sid << 8 | sid << 16 | sid << 24;
				循环 (by = by0; by < by1; by++) 
				{
					vy = 层->vy0 + by;
					循环 (bx = bx0; bx < bx1 && (bx & 3) != 0; bx++) 
					{
						/* 前一个分数一次是1个字节*/
						vx = 层->vx0 + bx;
						若 (网格[vy * 层管->x大小 + vx] == sid) 
						{
							显存[vy * 层管->x大小 + vx] = buf[by * 层->bx大小 + bx];
						}
					}
					vx = 层->vx0 + bx;
					p = (整型 *) &网格[vy * 层管->x大小 + vx];
					q = (整型 *) &显存[vy * 层管->x大小 + vx];
					r = (整型 *) &buf[by * 层->bx大小 + bx];
					循环 (i = 0; i < i1; i++)
					{
						/* 4的倍数 */
						若 (p[i] == sid4) 
						{
							q[i] = r[i];	/* 在许多情况下，它似乎是如此之快 */
						} 
						则 
						{
							bx2 = bx + i * 4;
							vx = 层->vx0 + bx2;
							/* 写四个很麻烦 */
							循环 (j = 0; j < 4; j++) 
							{
								若 (网格[vy * 层管->x大小 + vx + j] == sid) 
								{
									显存[vy * 层管->x大小 + vx + j] = buf[by * 层->bx大小 + bx2 + j];
								}
							}
						}
					}
					循环 (bx += i1 * 4; bx < bx1; bx++) 
					{
						/* 最后一个部分一次是1个字节 */
						vx = 层->vx0 + bx;
						若 (网格[vy * 层管->x大小 + vx] == sid)
							显存[vy * 层管->x大小 + vx] = buf[by * 层->bx大小 + bx];
					}
				}
			} 
			则 
			{
				/* 1 byte 类型 */
				循环 (by = by0; by < by1; by++) 
				{
					vy = 层->vy0 + by;
					循环 (bx = bx0; bx < bx1; bx++) 
					{
						vx = 层->vx0 + bx;
						若 (网格[vy * 层管->x大小 + vx] == sid)
							显存[vy * 层管->x大小 + vx] = buf[by * 层->bx大小 + bx];
					}
				}
			}
		} 
		则 若 (bpp == 16) 
		{
			buf16 = (无符号 短整型 *) (层->buf);
			/* 1 byte 类型 */
			循环 (by = by0; by < by1; by++) 
			{
				vy = 层->vy0 + by;
				循环 (bx = bx0; bx < bx1; bx++) 
				{
					vx = 层->vx0 + bx;
					若 (网格[vy * 层管->x大小 + vx] == sid)
						显存16[vy * 层管->x大小 + vx] = buf16[by * 层->bx大小 + bx];
				}
			}
		} 
		则 若 (bpp == 24) 
		{
			buf24 = (无符号 整型 *) (层->buf);
			/* 1 byte 类型 */
			循环 (by = by0; by < by1; by++) 
			{
				vy = 层->vy0 + by;
				循环 (bx = bx0; bx < bx1; bx++) 
				{
					vx = 层->vx0 + bx;
					若 (网格[vy * 层管->x大小 + vx] == sid)
						显存24[vy * 层管->x大小 + vx] = buf24[by * 层->bx大小 + bx];
				}
			}
		}
	}
	返回;
}

空 图层_上下(结构 图层 *层, 整型 高度)
{
	结构 图层管理 *层管 = 层->层管;
	整型 h, 旧的 = 层->高度; /* 存储set前的高度信息 */

/* 如果指定的高度过高或过低，则进行修正 */
	若 (高度 > 层管->顶 + 1)	// 太高
		高度 = 层管->顶 + 1;
	若 (高度 < -1)			// 太低
		高度 = -1;
	层->高度 = 高度;/* 设定高度 */
	

	/* 下面主要是进行图层[]的从新排列 */
	若 (旧的 > 高度) 
	{
		/* 比以前低 */
		若 (高度 >= 0) 
		{
			/* 提高旧和高度之间的底层 */
			循环 (h = 旧的; h > 高度; h--) {
				层管->图层s[h] = 层管->图层s[h - 1];
				层管->图层s[h]->高度 = h;
			}
			层管->图层s[高度] = 层;
			图层_刷新网格(层管, 层->vx0, 层->vy0, 层->vx0 + 层->bx大小, 层->vy0 + 层->by大小, 高度 + 1);
			图层_刷新sub(层管, 层->vx0, 层->vy0, 层->vx0 + 层->bx大小, 层->vy0 + 层->by大小, 高度 + 1, 旧的);
		} 
		则 
		{
			/* 隐藏高度（高哪里-1） */
			若 (层管->顶 > 旧的) 
			{
				/* 把上面的降下来 */
				循环 (h = 旧的; h < 层管->顶; h++) 
				{
					层管->图层s[h] = 层管->图层s[h + 1];
					层管->图层s[h]->高度 = h;
				}
			}
			层管->顶--; /* 由于显示中的图层减少了一个，所以最上面的图层高度下降 */
			图层_刷新网格(层管, 层->vx0, 层->vy0, 层->vx0 + 层->bx大小, 层->vy0 + 层->by大小, 0);
			图层_刷新sub(层管, 层->vx0, 层->vy0, 层->vx0 + 层->bx大小, 层->vy0 + 层->by大小, 0, 旧的 - 1);
		}
	} 
	则 若 (旧的 < 高度) 
	{
		/* 比以前高 */
		若 (旧的 >= 0) 
		{
			/* 按下旧和高度之间的衬垫 */
			循环 (h = 旧的; h < 高度; h++) 
			{
				层管->图层s[h] = 层管->图层s[h + 1];
				层管->图层s[h]->高度 = h;
			}
			层管->图层s[高度] = 层;
		} 
		则 
		{
		/* 显示（高度为0或更高） */
			循环 (h = 层管->顶; h >= 高度; h--) 
			{
				层管->图层s[h + 1] = 层管->图层s[h];
				层管->图层s[h + 1]->高度 = h + 1;
			}
			层管->图层s[高度] = 层;
			层管->顶++; /* 由于已经显示的图层增加了1个，所以最上面的图层高度增加 */
		}
		/* 使用新的参考信息重绘屏幕 */
		图层_刷新网格(层管, 层->vx0, 层->vy0, 层->vx0 + 层->bx大小, 层->vy0 + 层->by大小, 高度);
		图层_刷新sub(层管, 层->vx0, 层->vy0, 层->vx0 + 层->bx大小, 层->vy0 + 层->by大小, 高度, 高度);
	}
	返回;
}

空 图层_刷新(结构 图层 *层, 整型 bx0, 整型 by0, 整型 bx1, 整型 by1)
{
	若 (层->高度 >= 0) 
	{
		/* 如果正在显示，则按新图层的信息刷新画面 */
		图层_刷新sub(层->层管, 层->vx0 + bx0, 层->vy0 + by0,
						 层->vx0 + bx1, 层->vy0 + by1, 层->高度, 层->高度);
	}
	返回;
}

空 图层_位置(结构 图层 *层, 整型 vx0, 整型 vy0)
{
	整型 旧的_vx0 = 层->vx0, 旧的_vy0 = 层->vy0;
	层->vx0 = vx0;
	层->vy0 = vy0;
	若 (层->高度 >= 0) 
	{
		/* 如果正在显示,则按新图层的信息刷新画面 */
		图层_刷新网格(层->层管, 旧的_vx0, 旧的_vy0, 旧的_vx0 + 层->bx大小, 旧的_vy0 + 层->by大小, 0);
		图层_刷新网格(层->层管, vx0, vy0, vx0 + 层->bx大小, vy0 + 层->by大小, 层->高度);
		图层_刷新sub(层->层管, 旧的_vx0, 旧的_vy0, 旧的_vx0 + 层->bx大小, 旧的_vy0 + 层->by大小, 0, 层->高度 - 1);
		图层_刷新sub(层->层管, vx0, vy0, vx0 + 层->bx大小, vy0 + 层->by大小, 层->高度, 层->高度);
	}
	返回;
}

空 图层_可用(结构 图层 *层)
{
	若 (层->高度 >= 0)
		图层_上下(层, -1);	/* 如果处于显示状态，则先设定为隐藏 */
	层->标记 = 0;	/* "未使用"标志 */

	返回;
}
