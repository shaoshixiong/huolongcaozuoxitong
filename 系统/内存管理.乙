/* 内存管理相关 */
/* 作者 : 邵世雄 */
#引入 "主程序.头"

#定义 E标识_AC_BIT		0x00040000
#定义 CR0_缓存_禁用	0x60000000

无符号 整型 memtest(无符号 整型 开始, 无符号 整型 结束)
{
	字符 flg486 = 0;
	无符号 整型 eflg, cr0, i;

	/* 确认CPU是386还是486以上的 */
	eflg = 出入流_加载_e标记s() | E标识_AC_BIT;
	出入流_store_e标记s(eflg);
	eflg = 出入流_加载_e标记s() & E标识_AC_BIT;
	若 (eflg)/* 如果是386，即使设定AC=1,AC的值还会自动回到0 */
		flg486 = 1;
	eflg &= ~E标识_AC_BIT;		// 取消你做的
	出入流_store_e标记s(eflg);

	若 (flg486) 
	{
		cr0 = 加载_cr0() | CR0_缓存_禁用;	 /* 禁止缓存 */
		store_cr0(cr0);
	}

	i = memtest_sub(开始, 结束);

	若 (flg486) 
	{
		cr0 = 加载_cr0();
		cr0 &= ~CR0_缓存_禁用;	/* 允许缓存 */
		store_cr0(cr0);
	}

	返回 i;
}

空 内管_初始化(结构 内存管理 *内管)
{
	内管->可用s = 0;		/* 可用信息数目 */
	内管->max可用s = 0;/* 用于观察可用状况：可用s的最大值 */
	内管->lost大小 = 0;	/* 释放失败的内存的大小总和 */
	内管->losts = 0;		/* 释放失败次数 */
	返回;
}

无符号 整型 内管_总计(结构 内存管理 *内管)
/* 报告可用内存大小的合计 */
{
	无符号 整型 i, t = 0;
	循环 (i = 0; i < 内管->可用s; i++)
		t += 内管->可用[i].大小;
	返回 t;
}

无符号 整型 内管_分配(结构 内存管理 *内管, 无符号 整型 大小)
/* 分配 */
{
	无符号 整型 i, a;
	循环 (i = 0; i < 内管->可用s; i++) 
	{
		若 (内管->可用[i].大小 >= 大小) 
		{
			/* 找到了足够大的内存 */
			a = 内管->可用[i].添加r;
			内管->可用[i].添加r += 大小;
			内管->可用[i].大小 -= 大小;
			若 (内管->可用[i].大小 == 0) 
			{
				/* 如果可用[i]变成了0，就减掉一条可用信息 */
				内管->可用s--;
				循环 (; i < 内管->可用s; i++)
					内管->可用[i] = 内管->可用[i + 1];
			}
			返回 a;
		}
	}
	返回 0;  /* 没有可用空间 */
}

整型 内管_可用(结构 内存管理 *内管, 无符号 整型 添加r, 无符号 整型 大小)
/* 释放 */
{
	整型 i, j;

	/* 为了便于归纳内存，将可用[]按照添加r的顺序排列 */
	/* 所以，先决定应该放在哪里 */
	循环 (i = 0; i < 内管->可用s; i++) 
	{
		若 (内管->可用[i].添加r > 添加r)
			终止;
	}
	/* 可用[i - 1].添加r < 添加r < 可用[i].添加r */
	若 (i > 0) 
	{
		/* 模式1-1:在放的地方前面 */
		若 (内管->可用[i - 1].添加r + 内管->可用[i - 1].大小 == 添加r) 
		{
			/* 可以与前面的可用内存归纳到一起 */
			内管->可用[i - 1].大小 += 大小;
			若 (i < 内管->可用s) 
			{
				/*模式1-2:比放入的地方后面也有 */
				若 (添加r + 大小 == 内管->可用[i].添加r) 
				{
					/* 后面的领域也能归纳 */
					内管->可用[i - 1].大小 += 内管->可用[i].大小;
					/* 内管->可用[i]删除 */
					内管->可用s--;
					循环 (; i < 内管->可用s; i++)
						内管->可用[i] = 内管->可用[i + 1];
				}
			}
			返回 0;	 /* 成功完成 */
		}
	}
	若 (i < 内管->可用s) 
	{
		/* 不能与前面的可用空间归纳到一起 */
		若 (添加r + 大小 == 内管->可用[i].添加r) 
		{
			/* 可以与后面的内容归纳到一起 */
			内管->可用[i].添加r = 添加r;
			内管->可用[i].大小 += 大小;
			返回 0;	 /* 成功完成 */
		}
	}
	若 (内管->可用s < 内存管理_FREES) 
	{
		/* 即不能与前面归纳到一起，也不能与后面归纳到一起 */
		/* 可用[i]之后的，向后移动，腾出一点可用空间 */
		循环 (j = 内管->可用s; j > i; j--)
			内管->可用[j] = 内管->可用[j - 1];
		内管->可用s++;
		若 (内管->max可用s < 内管->可用s)
			内管->max可用s = 内管->可用s;/* 更新最大值 */
			内管->可用[i].添加r = 添加r;
			内管->可用[i].大小 = 大小;
			返回 0;	 /* 成功完成 */
	}
	/* 不能往后移动 */
	/* 模式4：因为无论如何都做不到“虽然可惜，还是扔掉吧” */
	内管->losts++;
	内管->lost大小 += 大小;
	返回 -1; /* 失败 */
}

无符号 整型 内管_分配_4k(结构 内存管理 *内管, 无符号 整型 大小)
{
	无符号 整型 a;
	大小 = (大小 + 0xfff) & 0xfffff000;
	a = 内管_分配(内管, 大小);
	返回 a;
}

整型 内管_可用_4k(结构 内存管理 *内管, 无符号 整型 添加r, 无符号 整型 大小)
{
	整型 i;
	大小 = (大小 + 0xfff) & 0xfffff000;
	i = 内管_可用(内管, 添加r, 大小);
	返回 i;
}
