/* 描绘.c */
/* 作者 : 邵世雄 */
#引入 "主程序.头"

整型 描绘_信息(结构 DLL_STRPICENV *env, 整型 *信息, 整型 大小, 字符 *fp)
{
	/* 自动判断 */
	若 (info_BMP(env, 信息, 大小, fp) == 0) 
	{
		/* BMP不是 */
		若 (信息_联像组(env, 信息, 大小, fp) == 0) 
		{
			/* 联像组没有 */
			若 (信息_图标(env, 信息, 大小, fp) == 0) 
			{
				/* 图标没有 */
				返回 0;
			}
		}
	}
	返回 1;
}

整型 描绘_解码0(整型 模式, 结构 DLL_STRPICENV *env, 整型 大小, 字符 *fp, 整型 b_类型, 字符 *buf, 整型 跳过)
{
	整型 i = 1;
	若 (模式 == 1) 
	{
		i = decode0_BMP (env, 大小, fp, b_类型, (字符 *) buf, 跳过);
	} 
	则 若 (模式 == 2) 
	{
		i = 解码0_联像组(env, 大小, fp, b_类型, (字符 *) buf, 跳过);
	} 
	则 若 (模式 == 4) 
	{
		i = 解码0_图标 (env, 大小, fp, b_类型, (字符 *) buf, 跳过);
	}
	返回 i;
}

无符号 字符 红绿蓝2pal(整型 r, 整型 g, 整型 b, 整型 x, 整型 y)
{
	静态 整型 表[4] = { 3, 1, 0, 2 };
	整型 i;
	x &= 1; /* 是偶数还是奇数 */
	y &= 1;
	i = 表[x + y * 2];	/* 颜色作为常数 */
	r = (r * 21) / 256;	/* 到此为止0～20 */
	g = (g * 21) / 256;
	b = (b * 21) / 256;
	r = (r + i) / 4;	/* 到此为止0～5 */
	g = (g + i) / 4;
	b = (b + i) / 4;
	返回 16 + r + g * 6 + b * 36;
}

/*
结构 绘画 {
	字符 名称[18], *文件buf;
	结构 红绿蓝 *picbuf;
	结构 DLL_STRPICENV *env;
	整型 f大小, 错, 信息[8];
	//	错 list
	//	1: File not found.
	//	2: File is not image.
};
*/

结构 绘画 *描绘_初始化(字符 *名称, 整型 *文件分配表)
{
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	结构 文件信息 *文信;
	结构 绘画 *pic = (结构 绘画 *) 内管_分配_4k(内管, 占字数(结构 绘画));
	整型 i;
	pic->名称    = 名称;
	pic->env     = (结构 DLL_STRPICENV *) 内管_分配_4k(内管, 占字数(结构 DLL_STRPICENV));
	pic->错     = 0;
	文信 = 文件_搜索(名称, (结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
	若 (文信 != 0) 
	{
		/* 找到照片文件的处理 */
		pic->f大小 = 文信->大小;
		pic->文件buf = 文件_加载文件2(文信->clustno, &(pic->f大小), 文件分配表);
		i = 描绘_信息(pic->env, pic->信息, pic->f大小, pic->文件buf);
		若 (i == 0) 
		{
			pic->错 = 2;
			返回 pic;
		}
		pic->picbuf = (结构 红绿蓝 *) 内管_分配_4k(内管, pic->信息[2] * pic->信息[3] * 占字数(结构 红绿蓝));
	} 
	则 
	{
		pic->错 = 1;
	}
	返回 pic;
}

整型 描绘_画(结构 图层 *层, 结构 绘画 *pic, 整型 px, 整型 py)
{
	结构 红绿蓝 *q;
	整型 i, j;
	整型 bpp = 获取_bpp();
	无符号 字符  *cp;
	无符号 短整型 *sp;

	i = 描绘_解码0(pic->信息[0], pic->env, pic->f大小, pic->文件buf,
										4, (无符号 字符 *) pic->picbuf, 0);
	若 (i != 0) 
	{
		返回 i;	// Picture 解码 error.
	}

	/* 显示处理 */
	若 (bpp == 8) 
	{
		循环 (i = 0; i < pic->信息[3]; i++) 
		{
			cp = 层->buf + (py + i) * 层->bx大小 + px;
			q = pic->picbuf + i * pic->信息[2];
			循环 (j = 0; j < pic->信息[2]; j++) 
			{
				cp[j] = 红绿蓝2pal(q[j].r, q[j].g, q[j].b, j, i);
			}
		}
	} 
	则 若 (bpp == 16) 
	{
		循环 (i = 0; i < pic->信息[3]; i++) 
		{
			sp = (无符号 短整型 *) (层->buf) + (py + i) * 层->bx大小 + px;
			q = pic->picbuf + i * pic->信息[2];
			循环 (j = 0; j < pic->信息[2]; j++) 
			{
				sp[j] = (无符号 短整型)(
							((pic->picbuf[i * pic->信息[2] + j].r << 8) & 0xf800) |
							((pic->picbuf[i * pic->信息[2] + j].g << 3) & 0x07e0) |
							(pic->picbuf[i * pic->信息[2] + j].b >> 3)
						);
			}
		}
	} 
	则 若 (bpp == 24) 
	{
		/* 未实现 */
	}
	返回 0;
}

空 描绘_可用(结构 绘画 *pic)
{
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	内管_可用_4k(内管, (整型) pic->文件buf, pic->f大小);
	内管_可用_4k(内管, (整型) pic->picbuf, pic->信息[2] * pic->信息[3] * 占字数(结构 红绿蓝));
	内管_可用_4k(内管, (整型) pic->env, 占字数(结构 DLL_STRPICENV));
	内管_可用_4k(内管, (整型) pic, 占字数(结构 绘画));
	返回;
}
