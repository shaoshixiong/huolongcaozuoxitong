/* 应用程序接口.乙 */
/* 作者 : 邵世雄 */
#引入 "主程序.头"

整型 *火龙_api(整型 edi, 整型 esi, 整型 ebp, 整型 esp, 整型 ebx, 整型 edx, 整型 ecx, 整型 eax)
{
	结构 任务 *任 = 任_当前();
	整型 ds_base = 任->ds_base;
	结构 控制台 *控制台 = 任->控制台;
	结构 图层管理 *层管 = (结构 图层管理 *) *((整型 *) 0x0fe4);
	结构 图层 *层;
	结构 先进先出32 *sys_进出 = (结构 先进先出32 *) *((整型 *) 0x0fec);
	整型 *reg = &eax + 1; /* 返回值 */
	整型 i;
	结构 文件信息 *文信;
	结构 文件句柄 *fh;
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	无符号 字符 *p;
	整型 *内存总计 = (整型 *) *((整型 *) 0x0fe2);
	结构 任务 *任2;
	结构 先进先出32 *进出;
	结构 启动信息 *启信 = (结构 启动信息 *) 地址_启动信息;
	整型 像素深度 = 启信->显卡模式;
	无符号 短整型 *sp;
	无符号 整型   *ip;
	结构 绘画 *pic;

	若 (edx == 1) 
	{
		控制台_放入字符(控制台, eax & 0xff, 1);
	} 
	则 若 (edx == 2) 
	{
		控制台_放入str0(控制台, (字符 *) ebx + ds_base);
	} 
	则 若 (edx == 3) 
	{
		控制台_放入str1(控制台, (字符 *) ebx + ds_base, ecx);
	} 
	则 若 (edx == 4) 
	{
		返回 &(任->tss.esp0);
	} 
	则 若 (edx == 5) 
	{
		层 = 图层_分配(层管);
		层->任 = 任;
		层->标记 |= 0x10;
		图层_设置buf(层, (字符 *) ebx + ds_base, esi, edi, eax);
		制作_窗体((无符号 整型 *) ((字符 *) ebx + ds_base), esi, edi, (字符 *) ecx + ds_base, 0, 0);
		层->窗体名称 = (字符 *) ecx + ds_base;
		图层_位置(层, ((层管->x大小 - esi) / 2) & ~3, (层管->y大小 - edi) / 2);
		键窗_关闭(层管->图层s[层管->顶 - 2]);
		图层_上下(层, 层管->顶 - 1);
		键窗_打开(层);
		进出32_放入(sys_进出, 0x4000);	/* 键_窗変更要求 */
		reg[7] = (整型) 层;
	} 
	则 若 (edx == 6) 
	{
		层 = (结构 图层 *) (ebx & 0xfffffffe);
		打印字体s((无符号 整型 *) (层->buf), 层->bx大小, esi, edi, 获取_颜色(1, eax), (字符 *) ebp + ds_base);
		若 ((ebx & 1) == 0) 
		{
			图层_刷新(层, esi, edi, esi + ecx * 8, edi + 16);
		}
	} 
	则 若 (edx == 7) 
	{
		层 = (结构 图层 *) (ebx & 0xfffffffe);
		实体盒((无符号 整型 *) (层->buf), 层->bx大小, 获取_颜色(1, ebp), eax, ecx, esi, edi);
		若 ((ebx & 1) == 0) 
		{
			图层_刷新(层, eax, ecx, esi + 1, edi + 1);
		}
	}
	则 若 (edx == 8) 
	{
		内管_初始化((结构 内存管理 *) (ebx + ds_base));
		ecx &= 0xfffffff0;	/* 16 位为单位 */
		内管_可用((结构 内存管理 *) (ebx + ds_base), eax, ecx);
	} 
	则 若 (edx == 9) 
	{
		ecx = (ecx + 0x0f) & 0xfffffff0;	/* 16字节单位上升 */
		reg[7] = 内管_分配((结构 内存管理 *) (ebx + ds_base), ecx);
	} 
	则 若 (edx == 10) 
	{
		ecx = (ecx + 0x0f) & 0xfffffff0;	/* 16字节单位上升 */
		内管_可用((结构 内存管理 *) (ebx + ds_base), eax, ecx);
	} 
	则 若 (edx == 11) 
	{
		层 = (结构 图层 *) (ebx & 0xfffffffe);
		i = 获取_颜色(1, eax);
		若 (像素深度 == 8) 
		{
			层->buf[层->bx大小 * edi + esi] = 获取_颜色(像素深度, i);
		} 
		则 若 (像素深度 == 16) 
		{
			sp = (无符号 短整型 *) (层->buf);
			sp[层->bx大小 * edi + esi] = 获取_颜色(像素深度, i);
		} 
		则 若 (像素深度 == 24) 
		{
			ip = (无符号 整型 *) (层->buf);
			ip[层->bx大小 * edi + esi] = 获取_颜色(像素深度, i);
		}
		若 ((ebx & 1) == 0) 
		{
			图层_刷新(层, esi, edi, esi + 1, edi + 1);
		}
	} 
	则 若 (edx == 12) 
	{
		层 = (结构 图层 *) ebx;
		图层_刷新(层, eax, ecx, esi, edi);
	} 
	则 若 (edx == 13) 
	{
		层 = (结构 图层 *) (ebx & 0xfffffffe);
		火龙_api_linewin(层, eax, ecx, esi, edi, 获取_颜色(1, ebp));
		若 ((ebx & 1) == 0) 
		{
			若 (eax > esi) 
			{
				i = eax;
				eax = esi;
				esi = i;
			}
			若 (ecx > edi) 
			{
				i = ecx;
				ecx = edi;
				edi = i;
			}
			图层_刷新(层, eax, ecx, esi + 1, edi + 1);
		}
	} 
	则 若 (edx == 14) 
	{
		图层_可用((结构 图层 *) ebx);
		键窗_打开(层管->图层s[层管->顶 - 2]);
	} 
	则 若 (edx == 15) 
	{
		循环 (;;) 
		{
			出入流_cli();
			若 (进出32_状态(&任->进出) == 0) 
			{
				若 (eax != 0) 
				{
					/* fifo car应用o */
					任_睡眠(任);	/* 睡不着 */
				} 
				则 
				{
					出入流_sti();
					reg[7] = -1;
					返回 0;
				}
			}
			i = 进出32_获取(&任->进出);
			出入流_sti();
			若 (i <= 1) 
			{
				/* 用于curcol */
				/* 因为应用程序执行中没有curcol，所以总是下一次点显示用1*/
					定时_初始化(控制台->定时, &任->进出, 1);
					定时_设置时间(控制台->定时, 50);
			}
			若 (i == 2) 
			{
				/* 打开curcol */
				控制台->curcol = 0xffffff;
			}
			若 (i == 3) 
			{
				/* 关闭curcol */
				控制台->curcol = -1;
			}
			若 (i == 4) 
			{
				定时_取消(控制台->定时);
				出入流_cli();
				进出32_放入(sys_进出, 控制台->层 - 层管->图层s0 + 2024);	/* 2024～2279 */
				控制台->层 = 0;
				出入流_sti();
			}
			若 (i >= 256) 
			{
				reg[7] = i - 256;
				返回 0;
			}
		}
	} 
	则 若 (edx == 16) 
	{
		reg[7] = (整型) 定时_分配();
		((结构 定时器 *) reg[7])->标记2 = 1;	/* 自动取消 */
	} 
	则 若 (edx == 17) 
	{
		定时_初始化((结构 定时器 *) ebx, &任->进出, eax + 256);
	} 
	则 若 (edx == 18) 
	{
		定时_设置时间((结构 定时器 *) ebx, eax);
	} 
	则 若 (edx == 19) 
	{
		定时_可用((结构 定时器 *) ebx);
	} 
	则 若 (edx == 20) 
	{
		若 (eax == 0) 
		{
			/*关掉声音 */
			i = 出入流_in8(0x61);
			出入流_out8(0x61, i & 0x0d);
		} 
		则 
		{
			i = 1193180000 / eax;
			出入流_out8(0x43, 0xb6);
			出入流_out8(0x42, i & 0xff);
			出入流_out8(0x42, i >> 8);
			i = 出入流_in8(0x61);
			出入流_out8(0x61, (i | 0x03) & 0x0f);
		}
	} 
	则 若 (edx == 21) 
	{
		循环 (i = 0; i < 8; i++) 
		{
			若 (任->文件句柄[i].buf == 0) 
			{
				终止;
			}
		}
		fh = &任->文件句柄[i];
		reg[7] = 0;
		若 (i < 8) 
		{
			文信 = 文件_搜索((字符 *) ebx + ds_base,
						(结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
			若 (文信 != 0) 
			{
				reg[7] = (整型) fh;
				fh->大小 = 文信->大小;
				fh->位置 = 0;
				fh->buf = 文件_加载文件2(文信->clustno, &fh->大小, 任->文件分配表);
			}
		}
	} 
	则 若 (edx == 22) 
	{
		fh = (结构 文件句柄 *) eax;
		内管_可用_4k(内管, (整型) fh->buf, fh->大小);
		fh->buf = 0;
	} 
	则 若 (edx == 23) 
	{
		fh = (结构 文件句柄 *) eax;
		若 (ecx == 0) 
		{
			fh->位置 = ebx;				/* 请求源文件头 */
		} 
		则 若 (ecx == 1) 
		{
			fh->位置 += ebx;				/* 找到原点当前访问位置 */
		} 
		则 若 (ecx == 2) 
		{
			fh->位置 = fh->大小 + ebx;	/* 找到原点文件的结束位置*/
		}
		若 (fh->位置 < 0) 
		{
			fh->位置 = 0;
		}
		若 (fh->位置 > fh->大小) 
		{
			fh->位置 = fh->大小;
		}
	} 
	则 若 (edx == 24) 
	{
		fh = (结构 文件句柄 *) eax;
		若 (ecx == 0) 
		{
			reg[7] = fh->大小;			/* 文件大小 */
		} 则 若 (ecx == 1) 
		{
			reg[7] = fh->位置;			/* 从文件开头到当前位置的大小 */
		} 则 若 (ecx == 2) 
		{
			reg[7] = fh->位置 - fh->大小;/* 从文件末端到当前位置的大小 */
		}
	} 
	则 若 (edx == 25) 
	{
		fh = (结构 文件句柄 *) eax;
		循环 (i = 0; i < ecx; i++) 
		{
			若 (fh->位置 == fh->大小) 
			{
				终止;
			}
			*((字符 *) ebx + ds_base + i) = fh->buf[fh->位置];
			fh->位置++;
		}
		reg[7] = i;
	} 
	则 若 (edx == 26) 
	{
		i = 0;
		循环 (;;) 
		{
			*((字符 *) ebx + ds_base + i) = 任->命令行[i];
			若 (任->命令行[i] == 0) 
			{
				终止;
			}
			若 (i >= ecx) 
			{
				终止;
			}
			i++;
		}
		reg[7] = i;
	} 
	则 若 (edx == 27) 
	{
		reg[7] = 任->语言模式;
	} 
	则 若 (edx == 0x1001) 
	{
		/* Haritomo common API tomo_获取tick() */
		reg[7] = 定管.计数;
	} 
	则 若 (edx == 0x1003) 
	{
		/* Haritomo common API tomo_设置语言() */
		任->语言模式 = ebx;
	} 
	则 若 (edx == 0x1004) 
	{
		/* Haritomo common API tomo_sys信息() */
		结构 系统_信息 *信息 = (结构 系统_信息 *) (eax + ds_base);
		信息->cyls  = 启信->cyls;
		信息->键盘灯状态  = 启信->键盘灯状态;
		信息->显卡模式 = 启信->显卡模式;
		信息->预设 = 启信->预设;
		信息->屏幕横坐标 = 启信->屏幕横坐标;
		信息->屏幕纵坐标 = 启信->屏幕纵坐标;
		信息->显存  = 启信->显存;
		信息->os_类型 = 4; /* ssxos */
	} 
	则 若 (edx == 0x1005) 
	{
		/* Haritomo common API tomo_sys时间() */
		结构 时间_信息 *时间 = (结构 时间_信息 *) (eax + ds_base);
		时间->年    = rtc_获取(0);
		时间->月   = rtc_获取(1);
		时间->日     = rtc_获取(2);
		时间->时    = rtc_获取(3);
		时间->分 = rtc_获取(4);
		时间->秒  = rtc_获取(5);
	} 
	则 若 (edx == 0x4002) 
	{
		/* ssxos API osak_放入ministr() */
		层 = (结构 图层 *) (ebx & 0xfffffffe);
		打印迷你字体s((无符号 整型 *) (层->buf), 层->bx大小, esi, edi, eax, (字符 *) ebp + ds_base);
		若 ((ebx & 1) == 0) 
		{
			图层_刷新(层, esi, edi, esi + ecx * 6, edi + 12);
		}
	} 
	则 若 (edx == 0x4003) 
	{
		/* ssxos API osak_exec() */
		/* 每个字符输入新控制台 */
		任2 = 打开_控制台任务(0, (整型) 内存总计);
		进出 = &任2->进出;
		p = (字符 *) (ebp + ds_base);
		循环 (i = 0; p[i] != 0; i++) 
		{
			进出32_放入(进出, p[i] + 256);
		}
		进出32_放入(进出, 10 + 256);
	} 
	则 若 (edx == 0x4004) 
	{
		/* ssxos API osak_获取buflen() */
		reg[7] = 像素深度 >> 3;
	} 
	则 若 (edx == 0x4005) 
	{
		/* ssxos API osak_获取颜色() */
		reg[7] = 获取_颜色(ebx, ecx);
	} 
	则 若 (edx == 0x4006) 
	{
		pic = 描绘_初始化((字符 *) ebp + ds_base, 任->文件分配表);
		reg[7] = (整型) pic;
		若 (pic->错 != 0) 
		{
			reg[7] = -1;
		}
	} 
	则 若 (edx == 0x4007) 
	{
		层 = (结构 图层 *) (ebx & 0xfffffffe);
		pic = (结构 绘画 *) eax;
		i = 描绘_画(层, pic, ecx, esi);
		若 (i == 0) 
		{
			若 ((ebx & 1) == 0) 
			{
				图层_刷新(层, ecx, esi, ecx + pic->信息[2] + 1, esi + pic->信息[3] + 1);
			}
			reg[7] = i;
		} 
		则 
		{
			reg[7] = -1;
		}
	} 
	则 若 (edx == 0x4008) 
	{
		pic = (结构 绘画 *) eax;
		描绘_可用(pic);
	} 
	则 若 (edx == 0x4009) 
	{
		reg[7] = rtc_获取(ecx);
	} 
	则 若 (edx == 0x400a) 
	{
		层 = 层管->图层s[层管->顶];
		图层_位置(层, edi, esi);
		进出32_放入(sys_进出, 0x4001);	/* 刷新鼠标坐标 */
	} 
	则 若 (edx == 0x400b) 
	{
		结构 鼠标_信息 *信息 = (结构 鼠标_信息 *) (eax + ds_base);
		层 = 层管->图层s[层管->顶];
		信息->x = 层->vx0;
		信息->y = 层->vy0;
	} 
	则 若 (edx == 0x4100) 
	{
		/* ssxos API osak_放入string窗() */
		层 = (结构 图层 *) (ebx & 0xfffffffe);
		打印字体s((无符号 整型 *) (层->buf), 层->bx大小, esi, edi, 获取_颜色(1, eax), (字符 *) ebp + ds_base);
		若 ((ebx & 1) == 0) 
		{
			图层_刷新(层, esi, edi, esi + ecx * 8, edi + 16);
		}
	} 则 若 (edx == 0x4101) 
	{
		/* ssxos API osak_boxfil窗() */
		层 = (结构 图层 *) (ebx & 0xfffffffe);
		实体盒((无符号 整型 *) (层->buf), 层->bx大小, ebp, eax, ecx, esi, edi);
		若 ((ebx & 1) == 0) 
		{
			图层_刷新(层, eax, ecx, esi + 1, edi + 1);
		}
	} 
	则 若 (edx == 0x4102) 
	{
		/* ssxos API osak_point() */
		层 = (结构 图层 *) (ebx & 0xfffffffe);
		i = 获取_颜色(像素深度, eax);
		若 (像素深度 == 8) 
		{
			层->buf[层->bx大小 * edi + esi] = i;
		} 
		则 若 (像素深度 == 16) 
		{
			sp = (无符号 短整型 *) (层->buf);
			sp[层->bx大小 * edi + esi] = i;
		} 
		则 若 (像素深度 == 24) 
		{
			ip = (无符号 整型 *) (层->buf);
			ip[层->bx大小 * edi + esi] = i;
		}
		若 ((ebx & 1) == 0) 
		{
			图层_刷新(层, esi, edi, esi + 1, edi + 1);
		}
	} 
	则 若 (edx == 0x4103) 
	{
		/* ssxos API osak_linewin() */
		层 = (结构 图层 *) (ebx & 0xfffffffe);
		火龙_api_linewin(层, eax, ecx, esi, edi, ebp);
		若 ((ebx & 1) == 0) 
		{
			若 (eax > esi) 
			{
				i = eax;
				eax = esi;
				esi = i;
			}
			若 (ecx > edi) 
			{
				i = ecx;
				ecx = edi;
				edi = i;
			}
			图层_刷新(层, eax, ecx, esi + 1, edi + 1);
		}
	}

	返回 0;
}

空 火龙_api_linewin(结构 图层 *层, 整型 x0, 整型 y0, 整型 x1, 整型 y1, 整型 col)
{
	整型 i, x, y, 长, dx, dy;
	整型 像素深度 = 获取_像素深度();
	整型 c = 获取_颜色(像素深度, col);	/* 转换颜色 */
	无符号 短整型 *sp;
	无符号 整型   *ip;

	dx = x1 - x0;
	dy = y1 - y0;
	x = x0 << 10;
	y = y0 << 10;
	若 (dx < 0){
		dx = - dx;
	}
	若 (dy < 0){
		dy = - dy;
	}
	若 (dx >= dy) 
	{
		长 = dx + 1;
		若 (x0 > x1) 
		{
			dx = - 1024;
		} 
		则 
		{
			dx = 1024;
		}
		若 (y0 <= y1) 
		{
			dy = ((y1 - y0 + 1) << 10) / 长;
		} 
		则 {
			dy = ((y1 - y0 - 1) << 10) / 长;
		}
	} 
	则 
	{
		长 = dy + 1;
		若 (y0 > y1) 
		{
			dy = - 1024;
		} 
		则 
		{
			dy = 1024;
		}
		若 (x0 <= x1) 
		{
			dx = ((x1 - x0 + 1) << 10) / 长;
		} 
		则 
		{
			dx = ((x1 - x0 - 1) << 10) / 长;
		}
	}

	若 (像素深度 == 8) 
	{
		循环 (i = 0; i < 长; i++) 
		{
			层->buf[(y >> 10) * 层->bx大小 + (x >> 10)] = c;
			x += dx;
			y += dy;
		}
	} 
	则 若 (像素深度 == 16) 
	{
		sp = (无符号 短整型 *) (层->buf);
		循环 (i = 0; i < 长; i++) 
		{
			sp[(y >> 10) * 层->bx大小 + (x >> 10)] = c;
			x += dx;
			y += dy;
		}
	} 
	则 若 (像素深度 == 24) 
	{
		ip = (无符号 整型 *) (层->buf);
		循环 (i = 0; i < 长; i++) 
		{
			ip[(y >> 10) * 层->bx大小 + (x >> 10)] = c;
			x += dx;
			y += dy;
		}
	}

	返回;
}
