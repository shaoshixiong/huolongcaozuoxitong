/* 多任务处理相关的 */
/* 作者 : 邵世雄 */
#引入 "主程序.头"

结构 任务管理 *任管;
结构 定时器 *任_定时;

结构 任务 *任_当前(空)
{
	结构 任务级别 *tl = &任管->级别[任管->当前_lv];
	返回 tl->任s[tl->当前];
}

空 任_添加(结构 任务 *任)
{
	结构 任务级别 *tl = &任管->级别[任->级别];
	tl->任s[tl->正在运行] = 任;
	tl->正在运行++;
	任->标记 = 2;  /*活动中*/
	返回;
}

空 任_移除(结构 任务 *任)
{
	整型 i;
	结构 任务级别 *tl = &任管->级别[任->级别];

	/* 寻找任所在的位置 */
	循环 (i = 0; i < tl->正在运行; i++) 
	{
		若 (tl->任s[i] == 任)
			终止;
	}
	tl->正在运行--;
	若 (i < tl->当前)
		tl->当前--;		/* 需要移动成员，要相应地处理 */
	若 (tl->当前 >= tl->正在运行)
		tl->当前 = 0;	/* 如果当前的值出现异常，则进行修正 */
	任->标记 = 1;	 /* 休眠中 */
	循环 (; i < tl->正在运行; i++)
		tl->任s[i] =tl->任s[i + 1]; /* 移动 */
	返回;
}

空 任_切换sub(空)
{
	整型 i;
	/* 寻找最上层的级别 */
	循环 (i = 0; i < 最大值_任务级别S; i++) 
	{
		若 (任管->级别[i].正在运行 > 0)
			终止;
	}
	任管->当前_lv = i;
	任管->lv_改变 = 0;
	返回;
}

空 任_空闲(空)
{
	循环 (;;)
		io_hlt();
}

结构 任务 *任_初始化(结构 内存管理 *内管)
{
	整型 i;
	结构 任务 *任, *空闲;
	结构 SEGMENT_DESCRIPTOR *gdt = (结构 SEGMENT_DESCRIPTOR *) 地址_GDT;
	任管 = (结构 任务管理 *) 内管_分配_4k(内管, 占字数 (结构 任务管理));
	循环 (i = 0; i < 最大值_任务S; i++) 
	{
		任管->任s0[i].标记 = 0;
		任管->任s0[i].sel = (任务_GDT0 + i) * 8;
		任管->任s0[i].tss.ldtr = (任务_GDT0 + 最大值_任务S + i) * 8;
		设置_segmdesc(gdt + 任务_GDT0 + i, 103, (整型) &任管->任s0[i].tss, AR_TSS32);
		设置_segmdesc(gdt + 任务_GDT0 + 最大值_任务S + i, 15, (整型) &任管->任s0[i].ldt, AR_LDT);
	}
	循环 (i = 0; i < 最大值_任务级别S; i++) 
	{
		任管->级别[i].正在运行 = 0;
		任管->级别[i].当前 = 0;
	}
	任 = 任_分配();
	任->标记 = 2;		/* 活动中标志 */
	任->优先 = 2;		/* 0.02秒 */
	任->级别 = 0;		// 最高级别
	任_添加(任);
	任_切换sub();		// 任务设置
	加载_tr(任->sel);
	任_定时 = 定时_分配();
	定时_设置时间(任_定时, 任->优先);

	空闲 = 任_分配();
	空闲->tss.esp = 内管_分配_4k(内管, 64 * 1024) + 64 * 1024;
	空闲->tss.eip = (整型) &任_空闲;
	空闲->tss.es  = 1 * 8;
	空闲->tss.cs  = 2 * 8;
	空闲->tss.ss  = 1 * 8;
	空闲->tss.ds  = 1 * 8;
	空闲->tss.fs  = 1 * 8;
	空闲->tss.gs  = 1 * 8;
	任_运行(空闲, 最大值_任务级别S - 1, 1);
	
	返回 任;
}

结构 任务 *任_分配(空)
{
	整型 i;
	结构 任务 *任;
	循环 (i = 0; i < 最大值_任务S; i++) 
	{
		若 (任管->任s0[i].标记 == 0) 
		{
			任 = &任管->任s0[i];
			任->标记 = 1;	/* 正在使用的标志 */
			任->tss.e标记s = 0x00000202;	/* IF = 1; */
			任->tss.eax = 0;	 /* 这里先置为0 */
			任->tss.ecx = 0;
			任->tss.edx = 0;
			任->tss.ebx = 0;
			任->tss.ebp = 0;
			任->tss.esi = 0;
			任->tss.edi = 0;
			任->tss.es = 0;
			任->tss.ds = 0;
			任->tss.fs = 0;
			任->tss.gs = 0;
			任->tss.io网格 = 0x40000000;
			任->tss.ss0 = 0;
			返回 任;
		}
	}
	返回 0;	 /* 全部正在使用 */
}

空 任_运行(结构 任务 *任, 整型 级别, 整型 优先)
{
	若 (级别 < 0)
		级别 = 任->级别;	/* 不改变级别 */
	若 (优先 > 0)
		任->优先 = 优先;

	若 (任->标记 == 2 && 任->级别 != 级别)
		任_移除(任);
		/* 这里执行之后标记的值会变为1，于是下面的if语句块也会被执行 */

	若 (任->标记 != 2) 
	{
		任->级别 = 级别;	/* 从休眠状态唤醒的情形 */
		任_添加(任);
	}

	任管->lv_改变 = 1;	/* 下次任务切换时检查级别 */
	返回;
}

空 任_睡眠(结构 任务 *任)
{
	结构 任务 *当前_任;
	若 (任->标记 == 2) 
	{
		当前_任 = 任_当前();
		任_移除(任);		/* 标志为1 */
		若 (任 == 当前_任) 
		{
			/* 因为休眠而改变本身 */
			任_切换sub();
			当前_任 = 任_当前(); /* 设置后获取“当前任务” */
			farjmp(0, 当前_任->sel);
		}
	}
	返回;
}

空 任_切换(空)
{
	结构 任务级别 *tl = &任管->级别[任管->当前_lv];
	结构 任务 *新_任, *当前_任 = tl->任s[tl->当前];

	tl->当前++;
	若 (tl->当前 == tl->正在运行)
		tl->当前 = 0;
	若 (任管->lv_改变) 
	{
		任_切换sub();
		tl = &任管->级别[任管->当前_lv];
	}
	新_任 = tl->任s[tl->当前];
	定时_设置时间(任_定时, 新_任->优先);
	若 (新_任 != 当前_任)
		farjmp(0, 新_任->sel);
	返回;
}
