/* 作者 : 邵世雄 */

定类型 无符号 字符 无符字符;

结构 DLL_STRPICENV { 整型 work[16384]; };

整型 信息_图标(结构 DLL_STRPICENV *env, 整型 *信息, 整型 大小, 无符字符 *fp);
整型 解码0_图标(结构 DLL_STRPICENV *env, 整型 大小, 无符字符 *fp, 整型 b_类型, 无符字符 *buf, 整型 跳过);
整型 解码0_图标部分(结构 DLL_STRPICENV *env, 整型 xsz, 整型 ysz, 整型 x0, 整型 y0, 整型 大小, 无符字符 *fp, 整型 b_类型, 无符字符 *buf, 整型 跳过);

定类型 结构 {
	整型 pnt;
	整型 头大小;
	整型 px;
	整型 py;
	整型 pbit;
}图标信息;

空 初始化_ico(无符字符 *fp, 图标信息 *图信)
{
	整型 c;

	//  获取头位置
	图信->pnt = fp[18] | fp[19] << 8 | fp[20] << 16 | fp[21] << 24;

	// 图标目录(16)
	图信->头大小 = fp[图信->pnt] | fp[图信->pnt+1] << 8 | fp[图信->pnt+2] << 16 | fp[图信->pnt+3] << 24;	// ヘッダサイズ
	图信->px = fp[图信->pnt+4] | fp[图信->pnt+5] << 8 | fp[图信->pnt+6] << 16 | fp[图信->pnt+7] << 24;		// アイコンの幅
	图信->py = fp[图信->pnt+8] | fp[图信->pnt+9] << 8;		// アイコンの高さ
	c = fp[图信->pnt+10] | fp[图信->pnt+11] << 8;
	图信->py = (c << 16)+图信->py / 2;

	// 获取颜色数目
	图信->pbit = fp[图信->pnt+14] | fp[图信->pnt+15] << 8;	// 色数(ビット単位)

	返回;
}


整型 信息_图标(结构 DLL_STRPICENV *env, 整型 *信息, 整型 大小, 无符字符 *fp)
{
	图标信息 *图信 = (图标信息 *) (((整型 *) env) + 128);
	整型 i, j, k;

	// 获取图标头
	i = fp[0] | fp[1] << 8;	// Reserved
	j = fp[2] | fp[3] << 8;	// Resource 类型
	k = fp[4] | fp[5] << 8;	// Icon's number.

	若 ((i) || ((j != 1) && (j != 2)) || (k < 1))
		返回 0;	// Not icon 文件.

	初始化_ico(fp, 图信);

	信息[0] = 0x0004;
	信息[1] = 0x0000;
	信息[2] = 图信->px;
	信息[3] = 图信->py;

	返回 1;
}

整型 解码0_图标(结构 DLL_STRPICENV *env, 整型 大小, 无符字符 *fp, 整型 b_类型, 无符字符 *buf, 整型 跳过)
{
	图标信息 *图信 = (图标信息 *) (((整型 *) env) + 128);
	整型 i, e, p, pp, x, y, px2, px3, off, 标记 = 0, mask[2], dmask = 0, col, cnt, *线;
	整型 pal[256];

	若 (b_类型 != 4)
		返回 2;	/* 修正错误参数 */

	初始化_ico(fp, 图信);

	// 获取压缩形式
	i = fp[图信->pnt+16] | fp[图信->pnt+17] << 8 | fp[图信->pnt+18] << 16 | fp[图信->pnt+19] << 24;	// 压缩形式
	若 (i)
		返回 1; // Not ready compressed 文件.

	//  获取调色板准备获取掩码
	p = 图信->pnt + 图信->头大小;
	若 (图信->pbit <= 8) 
	{
		i = 1<<图信->pbit;
		若 (i > 256)
			返回 1; // too many 颜色s.
		循环 (cnt = 0; cnt < i; cnt++) 
		{
			pal[cnt] = fp[p] | fp[p+1] << 8 | fp[p+2] << 16;
			p += 4;
		}
	}

	// 掩码获取准备
	px2 = (图信->px * 图信->pbit + 31) / 32 * 4;
	px3 = (图信->px + 31) / 32 * 4;
	off = p;
	pp = px2 * 图信->py + p;

	// 图标描绘
	x = 图信->px;
	y = 图信->py;
	mask[0] = 0;
	mask[1] = 0;
	dmask = 0;

	循环 (cnt = 0; cnt < 图信->px*图信->py; cnt++) 
	{
		若 (p >= 大小)
			终止;
		若 ((cnt % 图信->px) == 0) 
		{
			x -= 图信->px;
			y--;
			p = cnt / 图信->px * px2 + off;
			mask[0] = 0;
			mask[1] = cnt / 图信->px * px3 + pp;
			标记 = -1;
		}
		若 (mask[0] == 0) 
		{
			mask[0] = 0x80;
			dmask = fp[mask[1]];
			mask[1]++;
		}
		若 (图信->pbit > 8) 
		{
			e = 0;
			pal[0] = fp[p] | fp[p+1] << 8 | fp[p+2] << 16;
			p += 3;
	// 因为不被频繁使用，这次注释
	//		若 (pbit > 24) {
	//			h = fp[p];
	//			p++;
	//			p[y * px + x] = col;
	//			p获取 x,y
	//			r = r * h + (255 -h * rval) /255;
	//			g = g * h + (255 -h * gval) /255;
	//			b = b * h + (255 -h * gval) /255;
	//		}
		} 
		则 
		{
			若 (标记 < 0) 
			{
				i = fp[p];
				p++;
				标记 = 8-图信->pbit;
			}
			e = (i >> 标记) % (1 << 图信->pbit);
			若 (1<<图信->pbit <= e)
				终止;
			标记 -= 图信->pbit;
		}
		col = 0xC6C6C6;
		若 ((dmask & mask[0]) == 0)
			col = pal[e];
		线 = (整型*)&buf[y * (图信->px * (b_类型 % 7) + 跳过)];
		线[x] = col;
		mask[0] >>= 1;
		x++;
	}
	返回 0;
}

整型 解码0_图标部分(结构 DLL_STRPICENV *env, 整型 xsz, 整型 ysz, 整型 x0, 整型 y0, 整型 大小, 无符字符 *fp, 整型 b_类型, 无符字符 *buf, 整型 跳过)
{
	返回 1;		/*  修正错误 */
}
