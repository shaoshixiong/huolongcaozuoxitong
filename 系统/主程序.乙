/* bootpack相关的 */
/* 作者 : 邵世雄 */
#引入 "主程序.头"
#引入 <标准输入输出.头>

#定义 KEYCMD_LED	0xed

空 关闭_控制台任务(结构 任务 *任);
空 关闭_控制台(结构 图层 *层);
结构 图层 *搜索_图层(结构 图层管理 *层管, 整型 mx, 整型 my);
结构 图层 *打开_omnaomi(结构 图层管理 *层管, 无符号 整型 内存总计, 结构 图层 *旧的层);
空 任_b_main(结构 图层 *层_窗_b)
{
	结构 先进先出32 进出;
	结构 定时器 *定时_1s;
	整型 i, 进出buf[128], 计数 = 0, 计数0 = 0;
	字符 s[12];

	进出32_初始化(&进出, 128, 进出buf, 0);
	定时_1s = 定时_分配();
	定时_初始化(定时_1s, &进出, 100);
	定时_设置时间(定时_1s, 100);

	循环 (;;) {
		计数++;
		出入流_cli();
		若 (进出32_状态(&进出) == 0) {
			出入流_sti();
		} 则 {
			i = 进出32_获取(&进出);
			出入流_sti();
			若 (i == 100) {
				图层_刷新(层_窗_b, 0, 0, 层_窗_b->bx大小, 层_窗_b->by大小);
				sprintf(s, "%11d", 计数 - 计数0);
				打印字体s_asc_层(层_窗_b, 24, 28, 0x000000, 0xffffff, s, 0);
				
				计数0 = 计数;
				定时_设置时间(定时_1s, 100);
				
			}
		}
	}
}
空 系统时钟_任(空)
{结构 启动信息 *启信 = (结构 启动信息 *) 地址_启动信息;
	整型 i, j;
	字符 错, cnt;
	无符号 字符 s[6];
	静态 无符号 字符 adr[7] = { 0x00, 0x02, 0x04, 0x07, 0x08, 0x09, 0x32 };
	静态 无符号 字符 max[7] = { 0x60, 0x59, 0x23, 0x31, 0x12, 0x99, 0x99 };
	结构 任务 *任 = 任_当前();
	结构 定时器 *时钟_定时 = 定时_分配();
	定时_初始化(时钟_定时, &任->进出, 1);
	定时_设置时间(时钟_定时, 100);
无符号 字符 t[7];
	循环 (;;) {
		出入流_cli();
		若 (进出32_状态(&任->进出) == 0) {
			任_睡眠(任);
			出入流_sti();
		} 则 {
			i = 进出32_获取(&任->进出);
			出入流_sti();
			若 (i == 1) {
				循环 (cnt = 0; cnt < 3; cnt++) {
					错 = 0;
					循环 (j = 0; j < 7; j++) {
						出入流_out8(0x70, adr[j]);
						t[j] = 出入流_in8(0x71);
					}
					循环 (j = 0; j < 7; j++) {
						出入流_out8(0x70, adr[j]);
						若 (t[j] != 出入流_in8(0x71) || (t[j] & 0x0f) > 9 || t[j] > max[j]) {
							错 = 1;
						}
					}
					若 (错 == 0) {
						终止;
					}
				}
				结构 图层管理 *层管 = (结构 图层管理 *) *((整型 *) 0x0fe4);
				结构 图层 *层 = &层管->图层s0[1];
				sprintf(s, "%02X:%02X\0", t[2], t[1]);
				打印字体s_asc_层((无符号 整型 *)层,启信->屏幕横坐标-60,7, 0xffffff, 0x7A8A9D,s, 5);
	// 图层_刷新(层, 0, 0, 层->bx大小, 层->by大小);
								   
				定时_设置时间(时钟_定时, 100);
			}
		}
	}
}
空 任_时间_main(结构 图层 *层_时间)
{
	结构 启动信息 *启信 = (结构 启动信息 *) 地址_启动信息;
	结构 先进先出32 进出;
	结构 定时器 *定时_1s;
	整型 i, 进出buf[128], 计数 = 0, 计数0 = 0;
	字符 s[12];

	进出32_初始化(&进出, 128, 进出buf, 0);
	定时_1s = 定时_分配();
	定时_初始化(定时_1s, &进出, 100);
	定时_设置时间(定时_1s, 100);

	循环 (;;) {
		计数++;
		出入流_cli();
		若 (进出32_状态(&进出) == 0) {
			出入流_sti();
		} 则 {
			i = 进出32_获取(&进出);
			出入流_sti();
			若 (i == 100) {
				整型 ix, t[3];
	字符 sx[5];
	循环 (ix = 0; ix < 3; ix++) 
	{
		t[ix] = rtc_获取(ix+3);
	}
	// sprintf(sx, "%02d:%02d:%02d\n",  t[0], t[1],t[2]);
	 sprintf(sx, "%02d:%02d\n",  t[0], t[1] );
	打印字体s_asc_层((无符号 整型 *)层_时间,启信->屏幕横坐标-60,7, 0xffffff, 0x7A8A9D,sx, 5);
	图层_刷新(层_时间, 0, 0, 层_时间->bx大小, 层_时间->by大小);
				定时_设置时间(定时_1s, 6000);
				
			}
		}
	}
	
	
	// 整型 ix, t[3];
	// 字符 sx[5];
	// 循环 (ix = 0; ix < 3; ix++) 
	// {
		// t[ix] = rtc_获取(ix+3);
	// }
	// sprintf(sx, "%02d:%02d:%02d\n",  t[0], t[1],t[2]);
	 
	// 打印字体s_asc_层((无符号 整型 *)层_时间,90,7, 0xffffff, 0x7A8A9D,sx, 1);
	// 图层_刷新(层_时间, 0, 0, 层_时间->bx大小, 层_时间->by大小);
}

空 入口(空)
{
	/* System */
		结构 启动信息 *启信 = (结构 启动信息 *) 地址_启动信息;
		结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
		无符号 整型 内存总计;
		结构 先进先出32 进出, 键命令;
		整型 进出buf[128], 键命令_buf[32];
		结构 任务 *任_a, *任;
		结构 文件信息 *文信;
		整型 *文件分配表;
		整型 小列表[最大值_MINID];
		整型 像素深度 = 获取_像素深度();
	/* Keyboard */
		结构 鼠标_DEC mdec;
		静态 字符 键表0[0x80] = {
			/* 一般文字 */
			  0, 0x01, '1',  '2', '3', '4', '5', '6', '7', '8', '9', '0',  '-',  '^', 0x08, 0x09,
			'Q',  'W', 'E',  'R', 'T', 'Y', 'U', 'I', 'O', 'P', '@', '[', 0x0a,    0,  'A',  'S',
			'D',  'F', 'G',  'H', 'J', 'K', 'L', ';', ':',   0,   0, ']',  'Z',  'X',  'C',  'V',
			'B',  'N', 'M',  ',', '.', '/',   0, '*',   0, ' ',   0,   0,    0,    0,    0,    0,
			  0,    0,   0,    0,   0,   0,   0, '7', '8', '9', '-', '4',  '5',  '6',  '+',  '1',
			'2',  '3', '0',  '.',   0,   0,   0,   0,   0,   0,   0,   0,    0,    0,    0,    0,
			  0,    0,   0,    0,   0,   0,   0,   0,   0,   0,   0,   0,    0,    0,    0,    0,
			  0,    0,   0, 0x5c,   0,   0,   0,   0,   0,   0,   0,   0,    0, 0x5c,    0,    0
		};
		静态 字符 键表1[0x80] = {
			/*  按下 上档 */
			  0,    0, '!', 0x22, '#', '$', '%', '&', 0x27, '(', ')', '~',  '=', '~', 0x08, 0x09,
			'Q',  'W', 'E',  'R', 'T', 'Y', 'U', 'I',  'O', 'P', '`', '{', 0x0a,   0,  'A',  'S',
			'D',  'F', 'G',  'H', 'J', 'K', 'L', '+',  '*',   0,   0, '}',  'Z', 'X',  'C',  'V',
			'B',  'N', 'M',  '<', '>', '?',   0, '*',    0, ' ',   0,   0,    0,   0,    0,    0,
			  0,    0,   0,    0,   0,   0,   0, '7',  '8', '9', '-', '4',  '5', '6',  '+',  '1',
			'2',  '3', '0',  '.',   0,   0,   0,   0,    0,   0,   0,   0,    0,   0,    0,    0,
			  0,    0,   0,    0,   0,   0,   0,   0,    0,   0,   0,   0,    0,   0,    0,    0,
			  0,    0,   0,  '_',   0,   0,   0,   0,    0,   0,   0,   0,    0, '|',    0,    0
		};
		整型 键_上档 = 0, 键_控制 = 0, 键_换挡 = 0, 标记_e0 = 0;
		整型 键_键盘灯状态 = (启信->键盘灯状态 >> 4) & 7, 键命令_等待 = -1;
	/* Mouse */
		整型 mx, my, x = 0, y = 0, mmx = -1, mmy = -1, 新_mx = -1, 新_my = 0;
		整型 mmx2 = 0, 新_wx = 0x7fffffff, 新_wy = 0, 标记_鼠标 = 0;
	/* IME */
		无符号 字符 *chinese;
		外部 字符 mhbm[4096];
		整型 旧的语言;
	/* Sheets */
		结构 图层管理 *层管;
		无符号 字符 *buf_底层, *buf_鼠标, *buf_naomi;
		结构 图层  *层_底层, *层_鼠标, *层_naomi, *层 = 0, *键_窗, *层2 = 0;
	/* Balloon */
		无符号 字符 *buf_泡;
		结构 图层  *层_泡;
		结构 气泡 *开始菜单;
		整型 标记_泡 = 0;
	/* Misc */
		无符号 字符 s[40];
		整型 i, j;


	初始化_gdtidt();
	初始化_pic();
	出入流_sti(); /* 由于IDT / 片的初始化结束，取消了CPU中断禁止*/
	进出32_初始化(&进出, 128, 进出buf, 0);
	*((整型 *) 0x0fec) = (整型) &进出;
	初始化_pit();
	初始化_键盘(&进出, 256);
	启用_鼠标(&进出, 512, &mdec);
	出入流_out8(PIC0_IMR, 0xf8); /* 允许PIT，片1和键盘(11111000) */
	出入流_out8(PIC1_IMR, 0xef); /* 允许鼠标(11101111) */
	进出32_初始化(&键命令, 32, 键命令_buf, 0);

	内存总计 = memtest(0x00400000, 0xbfffffff);
	内管_初始化(内管);
	内管_可用(内管, 0x00001000, 0x0009e000); /*	0x00001000 - 0x0009efff */
	内管_可用(内管, 0x00400000, 内存总计 - 0x00400000);
	*((整型 *) 0x0fe2) = (整型) 内存总计;

	初始化_定管();
	初始化_调色板();
	层管 = 层管_初始化(内管, 启信->显存, 启信->屏幕横坐标, 启信->屏幕纵坐标);
	任_a = 任_初始化(内管);
	进出.任 = 任_a;
	任_运行(任_a, 1, 2);
	*((整型 *) 0x0fe4) = (整型) 层管;
	任_a->语言模式 = 0;

	/* 层_底层 */
	层_底层 = 图层_分配(层管);
	buf_底层 = (无符号 字符 *) 内管_分配_4k(内管, 启信->屏幕横坐标 * 启信->屏幕纵坐标 * (像素深度 >> 3));
	图层_设置buf(层_底层,  buf_底层,  启信->屏幕横坐标, 启信->屏幕纵坐标, -1);	/* 没有透明色 */
	初始化_屏幕((无符号 整型 *) buf_底层, 启信->屏幕横坐标, 启信->屏幕纵坐标);
	层_底层->标记 |= 0x01;	/* 背景 */

	/* 层_naomi */
	层_naomi = 图层_分配(层管);
	buf_naomi = (无符号 字符 *) 内管_分配_4k(内管, 启信->屏幕横坐标 * 启信->屏幕纵坐标 * (像素深度 >> 3));
	图层_设置buf(层_naomi, buf_naomi, 启信->屏幕横坐标,30, 99);	/* 透明色可用 */
	//初始化_任((无符号 整型 *) buf_naomi, 启信->屏幕横坐标, 启信->屏幕纵坐标);
	实体盒((无符号 整型 *)buf_naomi, 启信->屏幕横坐标, 0x7A8A9D,  0,     0, 启信->屏幕横坐标 -  1, 启信->屏幕纵坐标 - 28);
	// 实体盒((无符号 整型 *)buf_naomi, 启信->屏幕横坐标, 0x7A8A9D,  0,     启信->屏幕纵坐标 - 28, 启信->屏幕横坐标 -  1, 启信->屏幕纵坐标 - 28);
	// 实体盒((无符号 整型 *)buf_naomi, 启信->屏幕横坐标, 0x000000,  0,     启信->屏幕纵坐标 - 27, 启信->屏幕横坐标 -  1, 启信->屏幕纵坐标 - 27);
	// 实体盒((无符号 整型 *)buf_naomi, 启信->屏幕横坐标, 0x7A8A9D,  0,     启信->屏幕纵坐标 - 26, 启信->屏幕横坐标 -  1, 启信->屏幕纵坐标 -  1);
	//放入_naomi((无符号 整型 *) buf_naomi);
	
	// 整型 ix, t[3];
	// 字符 sx[5];
	// 循环 (ix = 0; ix < 3; ix++) 
	// {
		// t[ix] = rtc_获取(ix+3);
	// }
	// sprintf(sx, "%02d:%02d:%02d\n",  t[0], t[1],t[2]);
	打印字体s_asc_层((无符号 整型 *)层_naomi, 9,7, 0xffffff, 0x7A8A9D,"menu", 1);
	// 打印字体s_asc_层((无符号 整型 *)层_naomi, 启信->屏幕横坐标-90,7, 0xffffff, 0x7A8A9D,sx, 1);
	图层_刷新(层_naomi, 0, 0, 层_naomi->bx大小, 层_naomi->by大小);
	层_naomi->标记 |= 0x100;	/* 特殊窗口 */
// ///时间
结构 任务 *时钟 = 任_分配();
	整型 *时钟_进出 = (整型 *) 内管_分配_4k(内管, 128 * 4);
	时钟->tss.esp = 内管_分配_4k(内管, 64 * 1024) + 64 * 1024;
	时钟->tss.eip = (整型) &系统时钟_任;
	时钟->tss.es = 1 * 8;
	时钟->tss.cs = 2 * 8;
	时钟->tss.ss = 1 * 8;
	时钟->tss.ds = 1 * 8;
	时钟->tss.fs = 1 * 8;
	时钟->tss.gs = 1 * 8;
	任_运行(时钟, 1, 2); /* 级别=1, 优先=2 */
	进出32_初始化(&时钟->进出, 128, 时钟_进出, 时钟);
// /* 层_窗_b */
 
// 结构 任务 *任_时间;
	 
		// 层_naomi= 图层_分配(层管);
		// // buf_时间 = (无符号 字符 *) 内管_分配_4k(内管, 启信->屏幕横坐标 * 启信->屏幕纵坐标 * (像素深度 >> 3));
		// 图层_设置buf(层_naomi, buf_naomi, 启信->屏幕横坐标,30, 99);	/* 透明色可用 */
		 
		// 任_时间 = 任_分配();
		// 任_时间->tss.esp = 内管_分配_4k(内管, 64 * 1024) + 64 * 1024 - 8;
		// 任_时间->tss.eip = (整型) &任_时间_main;
		// 任_时间->tss.es = 1 * 8;
		// 任_时间->tss.cs = 2 * 8;
		// 任_时间->tss.ss = 1 * 8;
		// 任_时间->tss.ds = 1 * 8;
		// 任_时间->tss.fs = 1 * 8;
		// 任_时间->tss.gs = 1 * 8;
		// *((整型 *) (任_时间->tss.esp + 4)) = (整型) 层_naomi;
		// 任_运行(任_时间, 2, -1);
			// 图层_位置(层_naomi,  0,  0);
			// 图层_上下(层_naomi, 10);
	 
/////////////////

///多任务
/* 层_窗_b */
// 结构 图层 *层_窗_b[3];
// 无符号 字符 *buf_窗_b;
// 结构 任务 *任_b[3];
	// 循环 (i = 0; i < 3; i++) {
		// 层_窗_b[i] = 图层_分配(层管);
		// buf_窗_b = (无符号 字符 *) 内管_分配_4k(内管, 启信->屏幕横坐标 * 启信->屏幕纵坐标 * (像素深度 >> 3));
		// 图层_设置buf(层_窗_b[i], buf_窗_b, 144, 52, -1); /* */
		// sprintf(s, "任_b%d", i);
		// 制作_窗体((无符号 整型 *) buf_窗_b, 144, 52, s, 0,0);
		// 任_b[i] = 任_分配();
		// 任_b[i]->tss.esp = 内管_分配_4k(内管, 64 * 1024) + 64 * 1024 - 8;
		// 任_b[i]->tss.eip = (整型) &任_b_main;
		// 任_b[i]->tss.es = 1 * 8;
		// 任_b[i]->tss.cs = 2 * 8;
		// 任_b[i]->tss.ss = 1 * 8;
		// 任_b[i]->tss.ds = 1 * 8;
		// 任_b[i]->tss.fs = 1 * 8;
		// 任_b[i]->tss.gs = 1 * 8;
		// *((整型 *) (任_b[i]->tss.esp + 4)) = (整型) 层_窗_b[i];
		// 任_运行(任_b[i], 2, i + 1);
			// 图层_位置(层_窗_b[i],  0,  0);
			// 图层_上下(层_窗_b[i], 10+i);
	// }
/////////////////
	/* 层_泡 */
	层_泡 = 图层_分配(层管);
	buf_泡 = (无符号 字符 *) 内管_分配_4k(内管,启信->屏幕横坐标 * 启信->屏幕纵坐标  *(像素深度 >> 3));
	图层_设置buf(层_泡, buf_泡, 220,370,99);	/* 透明色可用 */
	// 开始菜单 = 制作_泡(内管, 层_泡, 0, 0, 6, 19, 1);
	 实体盒((无符号 整型 *)buf_泡, 启信->屏幕横坐标, 0xF0F0F0,  0,     0,  启信->屏幕横坐标 , 500);
	 打印字体s_asc_层((无符号 整型 *)层_泡, 9,7, 0x000000,0xF0F0F0,"命令", 1);
	 打印字体s_asc_层((无符号 整型 *)层_泡, 9,25, 0x000000,0xF0F0F0,"shutdown", 1);
	//图层_刷新(层_泡, 0, 0, 层_泡->bx大小, 层_泡->by大小);
	// 打印迷你字体s_asc_层(层_泡, 4, 3, 0x000000, 0xffffff, "My 名称 is naomisan", 19);
	层_泡->标记 |= 0x100;	/* 特殊窗口 */

	/* 层_控制台 */
	键_窗 = 打开_控制台(层管, 内存总计);
 // showColor();
	/* 层_鼠标 */
	层_鼠标 = 图层_分配(层管);
	buf_鼠标 = (无符号 字符 *) 内管_分配_4k(内管, 16 * 16 * (像素深度 >> 3));
	图层_设置buf(层_鼠标, buf_鼠标, 16, 16, 99);	/* 透明色番号は99 */
	初始化_鼠标_指针((无符号 整型 *) buf_鼠标, 99/* 背景色 */);
	mx = (启信->屏幕横坐标 - 16) / 2; /* 按显示画面在中央计算坐标 */
	my = (启信->屏幕纵坐标 - 16) / 2;

	图层_位置(层_底层,  0,  0);
	 图层_位置(键_窗,   8, 16);
	图层_位置(层_泡, 0, 启信->屏幕纵坐标 - 370);
	图层_位置(层_naomi, 0, 启信->屏幕纵坐标 - 30);
	图层_位置(层_鼠标, mx, my);
	图层_上下(层_底层,  0);
	 //图层_上下(键_窗,   1);
	图层_上下(层_naomi, 2);
	图层_上下(层_鼠标, 10);
	// 图层_上下(层_泡, 2);
	键窗_打开(键_窗);

	/* 设置初始键盘状态 */
	进出32_放入(&键命令, KEYCMD_LED);
	进出32_放入(&键命令, 键_键盘灯状态);

	/*汉语.字体的读取 */
	文件分配表 = (整型 *) 内管_分配_4k(内管, 4 * 2880);
	文件_读取文件分配表(文件分配表, (无符号 字符 *) (地址_磁盘镜像 + 0x000200));
	文信 = 文件_搜索("chinese.fnt", (结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
	若 (文信 != 0) 
	{
		i = 文信->大小;
		chinese = 文件_加载文件2(文信->clustno, &i, 文件分配表);
	} 
	则 
	{
		chinese = (无符号 字符 *) 内管_分配_4k(内管, 16 * 256 + 32 * 94 * 47);
		循环 (i = 16 * 256; i < 16 * 256 + 32 * 94 * 47; i++) 
		{
			chinese[i] = 0xff;	/* 用0xff填充全宽部分 */
		}
	}
	循环 (i = 0; i < 16 * 256; i++) 
	{
		chinese[i] = mhbm[i];	/* 复制半宽部分 */
	}
	*((整型 *) 0x0fe8) = (整型) chinese;
	
	/*加载壁纸*/
	// 字符 *命令行x = (字符 *) 内管_分配_4k(内管, 10*10);
	// 命令行x[0]='c';
	// 命令行x[1]='i';
	// 命令行x[2]='t';
	// 命令行x[3]='y';
	// 命令行x[4]='.';
	// 命令行x[5]='j';
	// 命令行x[6]='p';
	// 命令行x[7]='g';	 		
	结构 绘画 *墙纸 = 描绘_初始化("city.jpg", 文件分配表);	 
	描绘_画(层_底层, 墙纸, (层_底层->bx大小-墙纸->信息[2])/2, (层_底层->by大小-墙纸->信息[3])/2);
	描绘_可用(墙纸);	 
	图层_刷新(层_底层, 0, 0, 层_底层->bx大小, 层_底层->by大小);
	
	/*加???*/
	// 结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	// 结构 文件信息 *文信;
	// 结构 任务 *任 = 任_当前();
	// 整型 i = 0, j, k, 标记 = 0;
	// 字符 s[30];
	i=0;
	整型  k,标记 = 0;
	无符号 字符 *目录列表 = 0;
	整型 目录列表_大小, dir_clustno;
 
		文信 = (结构 文件信息 *) (地址_磁盘镜像 + 0x002600);
	 	整型 xx=0,yy=0;
	循环 (i = 0; i < 224; i++) 
	{
		// 若 (i != 0 && (i % 11) == 0) {
			// 打印字体s_asc_层((无符号 整型 *)层_底层, 9,75, 0x000000,0xF0F0F0,s, 1); 
			// 循环 (;;) {
				// 出入流_cli();
				// 若 (进出32_状态(&任->进出) == 0) {
					// 任_睡眠(任);
					// 出入流_sti();
				// } 则 {
					// k = 进出32_获取(&任->进出);
					// 出入流_sti();
					// 若 (256 <= k && k < 512) {
						// //控制台_新行(控制台);
						// 终止;
					// }
				// }
			// }
		// }
		若 (文信[i].名称[0] == 0x00) 
		{
			终止;
		}
		若 (文信[i].名称[0] != 0xe5) 
		{
			若 ((文信[i].类型 & 0x18) == 0) 
			{
				/* 普通文件 */
				// sprintf(s, "文件名称", 文信[i].大小);
				循环 (j = 0; j < 8; j++) 
				{
					s[j] = 文信[i].名称[j];
				}
				// s[10] = 文信[i].ext[0];
				// s[11] = 文信[i].ext[1];
				// s[12] = 文信[i].ext[2];
				
				整型 *文件分配表1= (整型 *) 内管_分配_4k(内管, 4 * 2880);
 文件_读取文件分配表(文件分配表1, (无符号 字符 *) (地址_磁盘镜像 + 0x000200));
	无符号 字符 *buf_图标;
	结构 图层 *层_图标;
	层_图标 = 图层_分配(层管);
	buf_图标 = (无符号 字符 *) 内管_分配_4k(内管, 启信->屏幕横坐标 * 启信->屏幕纵坐标 * (像素深度 >> 3));
	图层_设置buf(层_图标,  buf_图标,  32, 32, -1);	/* 没有透明的颜色 */
初始化_屏幕((无符号 整型 *) buf_图标, 启信->屏幕横坐标, 启信->屏幕纵坐标);	
	层_图标->标记 |= 0x01;	/* 背景 */
	
	// 字符 *命令行x1 = (字符 *) 内管_分配_4k(内管, 10*10);
	// 命令行x1[0]='n';
	// 命令行x1[1]='y';
	// 命令行x1[2]='a';
	// 命令行x1[3]='n';
	// 命令行x1[4]='p';
	// 命令行x1[5]='o';
	// 命令行x1[6]='.';
	// 命令行x1[7]='i';
	// 命令行x1[8]='c';
	// 命令行x1[9]='o';	
	结构 绘画 *墙纸1 = 描绘_初始化("nyanpo.ico", 文件分配表1);	 
	描绘_画(层_图标, 墙纸1, (层_图标->bx大小-墙纸1->信息[2])/2, (层_图标->by大小-墙纸1->信息[3])/2);
	描绘_可用(墙纸1);	 
	

		
	图层_位置(层_图标,  50*xx+20,  80*yy+10);
		图层_上下(层_图标,  1);
		
				打印字体s_asc_层((无符号 整型 *)层_底层, 50*xx+20,80*yy+50, 0xFFFFFF,0x000000,s, 0); 
				// 打印字体s_asc_层((无符号 整型 *)层_底层, 10,80*i+52, 0x413B31,0x000000,s, 0); 
				
				图层_刷新(层_图标, 0, 0, 层_图标->bx大小, 层_图标->by大小);
		图层_刷新(层_底层, 0, 0, 层_底层->bx大小, 层_底层->by大小);
		
		若(i == 7)
		{ 	xx=1;
			yy=0;
			}
	则{
		yy=yy+1;
	}
			} 
		}
	}
	// 若 (标记 == 1) {
			// 内管_可用_4k(内管, (整型) 目录列表, 目录列表_大小);
	// }
	 
	//计算机
	结构 图层 *层_计算机 = 图层_分配(层管);
	无符号 字符 *buf_计算机 = (无符号 字符 *) 内管_分配_4k(内管, (600) * (400) * (像素深度 >> 3));
	图层_设置buf(层_计算机, buf_计算机, 600, 400, -1);	/* 没有透明的颜色 */
	制作_窗体((无符号 整型 *) buf_计算机,600, 400, "wenjianguanli", 0, 0);
	图层_位置(层_计算机, 80, 80);
	图层_上下(层_计算机,  8);
	
	/* startup */
	文信 = 文件_搜索("火龙.hsf", (结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
	j = 2;
	若 (文信 != 0) 
	{
		字符 *ss;
		i = 文信->大小;
		ss = 文件_加载文件2(文信->clustno, &i, 文件分配表);
		循环 (x = 0; x < i; x++) 
		{
			若 (ss[x] == '#' && j == 2) 
			{
				/* 如果该行的开头有＃，请将其注释掉 */
				j = 1;
			}
			若 (ss[x] == 0x0a) 
			{
				/* 由于已到达行尾，因此取消注释标记 */
				j = 2;
			}
			若 (ss[x] != 0x0d && j != 1) 
			{
				进出32_放入(&键_窗->任->进出, ss[x] + 256);
			}
		}
		内管_可用_4k(内管, (整型) ss, i);
	}

	内管_可用_4k(内管, (整型) 文件分配表, 4 * 2880);

	/* 小列表的初始化 */
	循环(i = 0; i < 最大值_MINID; i++) 
	{
		小列表[i] = -1;		/* 未使用 */
	}

	循环 (;;) 
	{
		若 (进出32_状态(&键命令) > 0 && 键命令_等待 < 0) 
		{
			/*发送要发送到键盘的任何数据 */
			键命令_等待 = 进出32_获取(&键命令);
			wait_KBC_sendready();
			出入流_out8(PORT_KEYDAT, 键命令_等待);
		}
		出入流_cli();
		若 (进出32_状态(&进出) == 0) 
		{
			/* 由于fifo已成为car应用o，因此如果有待处理的绘图则执行 */
			若 (新_mx >= 0) 
			{
				出入流_sti();
				图层_位置(层_鼠标, 新_mx, 新_my);
				新_mx = -1;
			} 
			则 若 (新_wx != 0x7fffffff) 
			{
				出入流_sti();
				图层_位置(层, 新_wx, 新_wy);
				新_wx = 0x7fffffff;
			} 
			则 
			{
				任_睡眠(任_a);
				出入流_sti();
			}
		} 
		则 
		{
			i = 进出32_获取(&进出);
			出入流_sti();
			若 (键_窗 != 0 && 键_窗->标记 == 0) 
			{
				/* 输入窗口已关闭 */
				若 (层管->顶 == 2) 
				{
					/* 没有更多的鼠标和背景 */
					键_窗 = 0;
				} 
				则 
				{
					键_窗 = 层管->图层s[层管->顶 - 2];
					键窗_打开(键_窗);
				}
			}
			若 (256 <= i && i < 512) 
			{
				/* 键盘数据 */
				i -= 256;	// 先拉
				若 (i == 0xe0) 
				{
					/*  E0扩展密钥 */
					标记_e0 = 1;
				}
				若 (i < 0x80 && 标记_e0 == 0) 
				{
					/* 将密钥代码转换为字符代码 */
					若 (键_上档 == 0) 
					{
						s[0] = 键表0[i];
					} 
					则 若 (键_上档 == 1) 
					{
						s[0] = 键表1[i];
					}
				} 
				则 
				{
					s[0] = 0;
				}
				若 ('A' <= s[0] && s[0] <= 'Z')	
				{
					/* 字母输入 */
					若 (((键_键盘灯状态 & 4) == 0 && 键_上档 == 0) ||
						((键_键盘灯状态 & 4) != 0 && 键_上档 != 0)   ) 
					{
						s[0] += 0x20;	/* 转换为小写 */
					}
				}
				若 (标记_e0 == 1) 
				{
					若 (i == 0x35 || i == 0x1c) 
					{
						/* 回车键 */
						s[0] = 键表0[i];
					}
				}
				若 (0x47 <= i && i <= 0x53) 
				{
					若 (i != 0x4a && i != 0x4e) 
					{
						/* 数字小键盘和输入s，Del，Home，end，PgUp，PgDn，光标键*/
						若 (标记_e0 == 1 || (键_键盘灯状态 & 2) != 0) 
						{
							s[0] = 键表0[i] + 0x80;		// 一律に0x80を足す
						}
					}
				}
				若 (i == 0x0f && 键_换挡 != 0) 
				{
					/*  Alt + Tab键不受代码传输的影响 */
					s[0] = 0;
				}
				若 (s[0] != 0 && 键_窗 != 0) 
				{
					/* 普通字符，Enter，BackSpace，Tab */
					若 (键_控制 == 0) 
					{
						/* 控制台 */
						进出32_放入(&键_窗->任->进出, s[0] + 256);
					}
				}
				若 (i == 0x57 && 层管->顶 > 2) 
				{
					/* F11键 */
					图层_上下(层管->图层s[1], 层管->顶 - 2);
				}
				若 (i == 0x2a)
					键_上档 |= 1;			// 左移on
				若 (i == 0x36)
					键_上档 |= 2;			// 右移on
				若 (i == 0xaa)
					键_上档 &= ~1;		// 左移off
				若 (i == 0xb6)
					键_上档 &= ~2;		// 右移off
				若 (i == 0x1d) {
					若 (标记_e0 == 0) 
					{
						键_控制 |= 1;		// 左CTRLon
					} 
					则 
					{
						键_控制 |= 2;		// 右CTRLon
					}
				}
				若 (i == 0x9d) 
				{
					若 (标记_e0 == 0) 
					{
						键_控制 &= ~1;		// 左CTRLoff
					} 
					则 
					{
						键_控制 &= ~2;		// 右CTRLoff
					}
				}
				若 (i == 0x38) 
				{
					若 (标记_e0 == 0) 
					{
						键_换挡 |= 1;		// 左ALTon
					}
					则 
					{
						键_换挡 |= 2;		// 右ALTon
					}
				}
				若 (i == 0xb8) 
				{
					若 (标记_e0 == 0) 
					{
						键_换挡 &= ~1;		// 左ALToff
					} 
					则 
					{
						键_换挡 &= ~2;		// 右ALToff
					}
				}
				若 (i == 0x3a) 
				{
					/* CapsLock */
					键_键盘灯状态 ^= 4;
					进出32_放入(&键命令, KEYCMD_LED);
					进出32_放入(&键命令, 键_键盘灯状态);
				}
				若 (i == 0x45) 
				{
					/* NumLock */
					键_键盘灯状态 ^= 2;
					进出32_放入(&键命令, KEYCMD_LED);
					进出32_放入(&键命令, 键_键盘灯状态);
				}
				若 (i == 0x46) 
				{
					/* ScrollLock */
					键_键盘灯状态 ^= 1;
					进出32_放入(&键命令, KEYCMD_LED);
					进出32_放入(&键命令, 键_键盘灯状态);
				}
				若 (((i == 0x0f && 键_换挡 != 0) || i == 0x43) && 键_窗 != 0) 
				{
					/* Tab修改了 Alt + Tab or F9 */
					键窗_关闭(键_窗);
					j = 键_窗->高度 - 1;
					若 (j == 0) 
					{
						j = 层管->顶 - 2;
					}
					键_窗 = 层管->图层s[j];
					键窗_打开(键_窗);
				}
				若 (i == 0x2e && 键_控制 != 0 && 键_窗 != 0) 
				{
					/* Shift + F1修改了Ctrl + C. */
					任 = 键_窗->任;
					若 (任 != 0 && 任->tss.ss0 != 0) 
					{
						任->语言模式 = 任->语言模式0;	/* 撤消API更改的语言模式 */
						旧的语言 = 任_a->语言模式;		/*  暂时将task_a字模式与任务匹配 */
						任_a->语言模式 = 任->语言模式;
						控制台_放入str0(任->控制台, "\nBreak(键) :\n");
						任_a->语言模式 = 旧的语言;
						出入流_cli();
						任->tss.eax = (整型) &(任->tss.esp0);
						任->tss.eip = (整型) 甲语言_结束_应用;
						出入流_sti();
						任_运行(任, -1, 0);
					}
				}
				若 (i == 0x31 && 键_控制 != 0) 
				{
					/*  Shift + F2修改了 Ctrl + N  */
					/* 激活新创建的控制台 */
					键窗_关闭(键_窗);
					键_窗 = 打开_控制台(层管, 内存总计);
					图层_位置(键_窗, 8, 16);
					图层_上下(键_窗, 层管->顶 - 1);
					键窗_打开(键_窗);
				}
				若 (i != 0xe0 && 标记_e0 == 1) 
				{
					/* E0扩展 */
					标记_e0 = 0;
				}
				若 (i == 0xfa) 
				{
					/* 键盘接收数据 */
					键命令_等待 = -1;
				}
				若 (i == 0xfe) 
				{
					/* 键盘无法接收数据 */
					wait_KBC_sendready();
					出入流_out8(PORT_KEYDAT, 键命令_等待);
				}
			} 
			则 若 (512 <= i && i < 768) 
			{
				/* 鼠标 */
				若 (鼠标_解码(&mdec, i - 512)) 
				{
					/* 鼠标移动 */
					mx += mdec.x;
					my += mdec.y;
					若 (mx < 0)
						mx = 0;
					若 (my < 0)
						my = 0;
					若 (mx > 启信->屏幕横坐标 - 1)
						mx = 启信->屏幕横坐标 - 1;
					若 (my > 启信->屏幕纵坐标 - 1)
						my = 启信->屏幕纵坐标 - 1;
					新_mx = mx;
					新_my = my;
					若 ((mdec.btn != 0 || 标记_鼠标 != 0) && mmx < 0) 
					{
						/* 停止制作 */
						/* 从底部开始按顺序搜索标签指向的工作表 */
						层 = 搜索_图层(层管, mx, my);
						x = mx - 层->vx0;
						y = my - 层->vy0;
						若 (mdec.btn != 0 && 层 != 层_naomi) 
						{
							图层_上下(层_泡, -1);	/* 擦除气球 */
							标记_泡 = 0;
						}
					}
					若 (mdec.btn & 0x01) 
					{
						/* 左键 */
						标记_鼠标 |= 0x01;
						若 (mmx < 0) 
						{
							/* 正常模式 */
							若 ((层->标记 & 0x100) != 0) 
							{
								/* Naomi-san或开始菜单 */
								若 (层 == 层_naomi) 
								{
									若 (标记_泡 == 0) 
									{
										标记_泡 = 1;
										图层_上下(键_窗,   1);
										// 图层_位置(层_泡, 层_naomi->vx0 - 80, 层_naomi->vy0 - 30);
										图层_上下(层_泡, 层管->顶 - 1);
										
										// 打印字体s_asc_层((无符号 整型 *)层_底层, 100,300, 0xFFFFFF,0x000000,".epm 文件 循环mat error.\n", 0); 
											// 图层_刷新(层_底层, 0, 0, 层_底层->bx大小, 层_底层->by大小);
										///////////////////
										// showColor();
										结构 控制台 控制台;
	// 结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
		// 整型 *文件分配表 = (整型 *) 内管_分配_4k(内管, 4 * 2880);
		// 字符 *命令行xx = (字符 *) 内管_分配_4k(内管, 10*10);
// 命令行xx[0]='n';
	// 命令行xx[1]='c';
	// 命令行xx[2]='s';
	// 命令行xx[3]='t';
	// 命令行xx[4]=' ';
	// 命令行xx[5]='i';
	// 命令行xx[6]='n';
	// 命令行xx[7]='v';
	// 命令行xx[8]='a';
	// 命令行xx[9]='d';
	// 命令行xx[10]='e';
	// 命令行xx[11]='r';
	// 命令行xx[12]='.';
	// 命令行xx[13]='e';
	// 命令行xx[14]='p';
	// 命令行xx[15]='m'; 
										 命令_ncst(&控制台, "ncst invader.epm",内存总计);
										//////////////////
									}
									若 (标记_泡 == 2) 
									{
										标记_泡 = 3;
										图层_上下(键_窗,   -1);
										图层_上下(层_泡, -1);
									}
								}
							}
							若 ((层->标记 & 0xf00) == 0x200) 
							{
								/* 窗口被最小化 */
								标记_鼠标 |= 0x0130;
							}
							若 ((层->标记 & 0xf00) == 0) 
							{
								/* 像窗户一样 */
								图层_上下(层, 层管->顶 - 2);
								若 (层 != 键_窗 && 层 != 0) 
								{
									键窗_关闭(键_窗);
									键_窗 = 层;
									键窗_打开(键_窗);
								}
								/* 一般窗口 */
								若 (3 <= x && x < 层->bx大小 - 3 && 3 <= y && y < 21) 
								{
									mmx = mx;	/* 到窗口移动模式 */
									mmy = my;
									mmx2 = 层->vx0;
									新_wy = 层->vy0;
								}
								若 (5 <= y && y < 19) 
								{
									若 (层->bx大小 - 20 <= x && x < 层->bx大小 - 5) 
									{
										/* [X]按键 */
										标记_鼠标 |= 0x0110;
									}
									若 (层->bx大小 - 31 <= x && x < 层->bx大小 - 21) 
									{
										/* [_]按键 */
										标记_鼠标 |= 0x0120;
									}
								}
							}
						} 
						则 
						{
							若 ((标记_鼠标 & 0x0f00) == 0) 
							{
								x = mx - mmx;	/*移动计算 */
								y = my - mmy;
								/* 我没有按下按键等 */
								/* 窗口移动模式 */
								新_wx = (mmx2 + x + 2) & ~3;
								新_wy = 新_wy + y;
								mmy = my;		/* 移动后更新坐标 */
							}
						}
					} 
					则 若 (mdec.btn & 0x02) 
					{
						/* 右键单击 */
						标记_鼠标 |= 0x02;
						若 (mmx < 0) 
						{
							若 (层 == 层_naomi || (层->标记 & 0x200) != 0) 
							{
								mmx = mx;	/*  要移动模式 */
								mmy = my;
								mmx2 = 层->vx0;
								新_wy = 层->vy0;
							}
						} 
						则 
						{
							若 ((标记_鼠标 & 0x0f00) == 0) 
							{
								x = mx - mmx;	/*移动计算 */
								y = my - mmy;
								/* 我没有按下按键等 */
								/* 窗口移动模式 */
								新_wx = (mmx2 + x + 2) & ~3;
								新_wy = 新_wy + y;
								mmy = my;		/* 移动后更新坐标 */
							}
						}
					} 
					则 若 (mdec.btn == 0) 
					{
						/* 什么都没有 */
						若 (标记_鼠标 & 0x01) 
						{
							/* 左终止 */
							若 ((标记_鼠标 & 0x0f00) == 0x0100 && 5 <= y && y < 19) 
							{
								/* 窗户围栏 */
								若 ((标记_鼠标 & 0xf0) == 0x10 && 层->bx大小 - 20 <= x && x < 层->bx大小 - 5) 
								{
									/* 窗口关闭 */
									任 = 层->任;
									若 ((层->标记 & 0x10) != 0) 
									{
										/* 是应用程序制作的窗口吗？ */
										任->语言模式 = 任->语言模式0;	/* 撤消API更改的语言模式 */
										旧的语言 = 任_a->语言模式;		/*  暂时将task_a字模式与任务匹配 */
										任_a->语言模式 = 任->语言模式;
										控制台_放入str0(任->控制台, "\nBreak(鼠标) :\n");
										任_a->语言模式 = 旧的语言;
										出入流_cli();
										任->tss.eax = (整型) &(任->tss.esp0);
										任->tss.eip = (整型) 甲语言_结束_应用;
										出入流_sti();
										任_运行(任, -1, 0);
									} 
									则 
									{
										/* Console */
										图层_上下(层, -1);	/* 隐藏现在 */
										键窗_关闭(键_窗);
										键_窗 = 0;
										若 (层管->顶 > 2) 
										{
											键_窗 = 层管->图层s[层管->顶 - 2];
											键窗_打开(键_窗);
										}
									}
								}
								若 ((标记_鼠标 & 0xf0) == 0x20 && 层->bx大小 - 31 <= x && x < 层->bx大小 - 21) 
								{
									/* [_]按键点击 */
									图层_上下(层, -100);	/* 隐藏 */
									键窗_关闭(键_窗);
									键_窗 = 0;
									层2 = 打开_omnaomi(层管, 内存总计, 层);
									图层_位置(层2, 层->vx0 + 层->bx大小 - 45, 层->vy0);
									若 (层管->顶 > 2) 
									{
										键_窗 = 层管->图层s[层管->顶 - 2];
										键窗_打开(键_窗);
									}
									图层_上下(层2, 1);
									循环(j = 0; j < 最大值_MINID; j++) 
									{
										若 (小列表[j] < 0) 
										{
											小列表[j] = 1;		/* min_id使用中 */
											层2->min_id = j;	/*  匹配标签？ */
											层->min_id = j;
											终止;
										}
									}
								}
								若 ((标记_鼠标 & 0xf0) == 0x30) 
								{
									/* 点击Omelette Naomi */
									键窗_关闭(键_窗);
									循环 (j = 0; j < 最大值_图层S; j++) 
									{
										键_窗 = &层管->图层s0[j];
										若 (键_窗->高度 < 0) 
										{
											若 (键_窗->min_id == 层->min_id) 
											{
												小列表[层->min_id] = -1;
												层->min_id = -1;
												键_窗->min_id = -1;
												图层_可用(层);
												图层_位置(键_窗, 层->vx0 - 键_窗->bx大小 + 42, 层->vy0);
												图层_上下(键_窗, 层管->顶 - 1);
												键窗_打开(键_窗);
												终止;
											}
										}
									}
								}
							}
							/* Naomi-san或开始菜单 */
							若 (标记_泡 == 1) 
							{
								标记_泡 = 2;
							} 则 若 (标记_泡 == 3) 
							{
								标记_泡 = 0;
							}
						} 则 若 (标记_鼠标 & 0x02) 
						{
							/* 右终止 */
						}
						标记_鼠标 = 0;
						mmx = -1;	/* 正常模式 */
						若 (新_wx != 0x7fffffff) 
						{ 
							图层_位置(层, 新_wx, 新_wy);	/* 确认一次  */
							新_wx = 0x7fffffff;
						}
					}
				}
			} 
			则 若 (768 <= i && i < 1024) 
			{
				关闭_控制台(层管->图层s0 + (i - 768));
			} 
			则 若 (1024 <= i && i < 2024) 
			{
				关闭_控制台任务(任管->任s0 + (i - 1024));
			} 
			则 若 (2024 <= i && i < 2280) 
			{
				/* 仅关闭控制台 */
				层2 = 层管->图层s0 + (i - 2024);
				内管_可用_4k(内管, (整型) 层2->buf, 256 * 165);
				图层_可用(层2);
			} 
			则 若 (i == 0x4000) 
			{
				/* 键_窗変更要求 from 应用程序接口.乙 */
				键_窗 = 层管->图层s[层管->顶 - 2];
			} 
			则 若 (i == 0x4001) 
			{
				/* 刷新鼠标坐标 from 应用程序接口.乙 - 0x400a */
				mx = 层_鼠标->vx0;
				my = 层_鼠标->vy0;
			}
		}
	}
}
空 showColor33()
{
	结构 控制台 控制台;
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
		整型 *文件分配表 = (整型 *) 内管_分配_4k(内管, 4 * 2880);
		字符 *命令行xx = (字符 *) 内管_分配_4k(内管, 10*10);
	命令行xx[0]='i';
	命令行xx[1]='n';
	命令行xx[2]='v';
	命令行xx[3]='a';
	命令行xx[4]='d';
	命令行xx[5]='e';
	命令行xx[6]='r';
	命令行xx[7]='.';
	命令行xx[8]='e';
	命令行xx[9]='p';
	命令行xx[10]='m'; 
	  命令_应用(&控制台,文件分配表,命令行xx);
	  返回;
}
空 showColor()
{
	 
结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	整型 *文件分配表 = (整型 *) 内管_分配_4k(内管, 4 * 2880);
	文件_读取文件分配表(文件分配表, (无符号 字符 *) (地址_磁盘镜像 + 0x000200));
	结构 文件信息 *文信;
	结构 图层管理 *层管;
	结构 图层 *层;
	字符 名称[18], *p, *q;
	结构 任务 *任 = 任_当前();
	整型 i;
	整型 seg大小, dat大小, esp, dat火龙, 应用大小;

	任->语言模式0 = 任->语言模式;
	字符 *命令行xx = (字符 *) 内管_分配_4k(内管, 10*10);
	命令行xx[0]='c';
	命令行xx[1]='o';
	命令行xx[2]='l';
	命令行xx[3]='o';
	命令行xx[4]='r';
	命令行xx[5]='.';
	命令行xx[6]='e';
	命令行xx[7]='p';
	命令行xx[8]='m'; 
/*  从命令行生成文件名 */
	// 循环 (i = 0; i < 13; i++) {
		// 若 (命令行xx[i] <= ' ')
			// 终止;
		// 名称[i] = 命令行xx[i];
	// }
	// 名称[i] = 0;
 
	文信 = 文件_搜索("invader.epm", (结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
	// 若 (文信 == 0 && 名称[i - 1] != '.') {
		// /* 找不到，用EPM重试 */
		// 名称[i    ] = '.';
		// 名称[i + 1] = 'e';
		// 名称[i + 2] = 'p';
		// 名称[i + 3] = 'm';
		// 名称[i + 4] = 0;
		// 文信 = 文件_搜索(命令行xx, (结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
	// }
	// 若 (文信 == 0) {
		// /* 仍然不合理 */
		// // 返回 0;
	// }

	/* 有一个档案 */
	应用大小 = 文信->大小;
	p = 文件_加载文件2(文信->clustno, &应用大小, 文件分配表);
	// 若 (应用大小 >= 36 && strncmp(p + 4, "Hari", 4) == 0 && *p == 0x00) {
		seg大小 = *((整型 *) (p + 0x0000));
		esp     = *((整型 *) (p + 0x000c));
		dat大小 = *((整型 *) (p + 0x0010));
		dat火龙  = *((整型 *) (p + 0x0014));
		q = (字符 *) 内管_分配_4k(内管, seg大小);
		任->ds_base = (整型) q;
		设置_segmdesc(任->ldt + 0, 应用大小 - 1, (整型) p, AR_CODE32_ER + 0x60);
		设置_segmdesc(任->ldt + 1, seg大小 - 1, (整型) q, AR_DATA32_RW + 0x60);
		循环 (i = 0; i < dat大小; i++)
			q[esp + i] = p[dat火龙 + i];
		start_应用(0x1b, 0 * 8 + 4, esp, 1 * 8 + 4, &(任->tss.esp0));
		层管 = (结构 图层管理 *) *((整型 *) 0x0fe4);
		循环 (i = 0; i < 最大值_图层S; i++) 
		{
			层 = &(层管->图层s0[i]);
			若 ((层->标记 & 0x11) == 0x11 && 层->标记 && 层->任 == 任) 
			{
				/* 应用程序结束了，但仍有一个底层 */
				图层_可用(层);		/* 关闭 */
			}
		}
		循环 (i = 0; i < 8; i++) 
		{
			/* 关闭未关闭的文件 */
			若 (任->文件句柄[i].buf != 0) 
			{
				内管_可用_4k(内管, (整型) 任->文件句柄[i].buf, 任->文件句柄[i].大小);
				任->文件句柄[i].buf = 0;
			}
		}
		任->语言模式 = 任->语言模式0;		// 撤消API更改的语言模式
		定时_取消所有(&任->进出);
		内管_可用_4k(内管, (整型) q, seg大小);
		任->语言字节1 = 0;
	// } 则 {
		// 打印字体s_asc_层((无符号 整型 *)层_底层, 100,300, 0xFFFFFF,0x000000,".epm 文件 循环mat error.\n", 0); 
		// // 控制台_放入str0(控制台, ".epm 文件 循环mat error.\n");
	// }
	内管_可用_4k(内管, (整型) p, 应用大小); 
}

空 键窗_关闭(结构 图层 *键_窗)
{
	改变_窗口标题(键_窗, 0);
	若 ((键_窗->标记 & 0x20) != 0) 
	{
		进出32_放入(&键_窗->任->进出, 3);	/* 控制台光标关闭 */
	}
	返回;
}

空 键窗_打开(结构 图层 *键_窗)
{
	改变_窗口标题(键_窗, 1);
	若 ((键_窗->标记 & 0x20) != 0) 
	{
		进出32_放入(&键_窗->任->进出, 2);	/* 控制台光标打开 */
	}
	返回;
}

结构 任务 *打开_控制台任务(结构 图层 *层, 无符号 整型 内存总计)
{
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	结构 任务 *任 = 任_分配();
	整型 *控制台_进出 = (整型 *) 内管_分配_4k(内管, 128 * 4);
	任->控制台_stack = 内管_分配_4k(内管, 64 * 1024);
	任->tss.esp = 任->控制台_stack + 64 * 1024 - 12;
	任->tss.eip = (整型) &控制台_任;
	任->tss.es = 1 * 8;
	任->tss.cs = 2 * 8;
	任->tss.ss = 1 * 8;
	任->tss.ds = 1 * 8;
	任->tss.fs = 1 * 8;
	任->tss.gs = 1 * 8;
	*((整型 *) (任->tss.esp + 4)) = (整型) 层;
	*((整型 *) (任->tss.esp + 8)) = 内存总计;
	任_运行(任, 2, 2);
	进出32_初始化(&任->进出, 128, 控制台_进出, 任);
	返回 任;
}

结构 图层 *打开_控制台(结构 图层管理 *层管, 无符号 整型 内存总计)
{
/* Old Window 大小 : 256 * 165 (TextBox : 240, 128) */
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	结构 图层 *层 = 图层_分配(层管);
	整型 像素深度 = 获取_像素深度();
	无符号 字符 *buf = (无符号 字符 *) 内管_分配_4k(内管, (控制台_SIZEX + 16) * (控制台_SIZEY + 37) * (像素深度 >> 3));
	图层_设置buf(层, buf, 控制台_SIZEX + 16, 控制台_SIZEY + 37, -1);	/* 没有透明的颜色 */
	制作_窗体((无符号 整型 *) buf, 控制台_SIZEX + 16, 控制台_SIZEY + 37, "控制台", 0, 0);
	制作_文本框(层, 8, 28, 控制台_SIZEX, 控制台_SIZEY, 0x000000);
	层->任 = 打开_控制台任务(层, 内存总计);
	层->标记 |= 0x20;	/* 用光标 */
	返回 层;
}

结构 图层 *打开_omnaomi(结构 图层管理 *层管, 无符号 整型 内存总计, 结构 图层 *旧的层)
{
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	结构 图层 *层 = 图层_分配(层管);
	整型 像素深度 = 获取_像素深度();
	无符号 字符 *buf;

	buf = (无符号 字符 *) 内管_分配_4k(内管, 31 * 16 * (像素深度 >> 3));
	图层_设置buf(层, buf, 31, 16, 99);
	制作_omnaomi(层, 0, 0);
	层->标记 |= 0x0200;
	返回 层;
}

空 关闭_控制台任务(结构 任务 *任)
{
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	任_睡眠(任);
	内管_可用_4k(内管, 任->控制台_stack, 64 * 1024);
	内管_可用_4k(内管, (整型) 任->进出.buf, 128 * 4);
	任->标记 = 0;	/* 任_可用(任);而不是 */
	
}

空 关闭_控制台(结构 图层 *层)
{
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	结构 任务 *任 = 层->任;
	内管_可用_4k(内管, (整型) 层->buf, 256 * 165);
	图层_可用(层);
	关闭_控制台任务(任);
	返回;
}

结构 图层 *搜索_图层(结构 图层管理 *层管, 整型 mx, 整型 my)
{
	结构 图层 *层 = 0;
	整型 i, x, y;
	循环 (i = 层管->顶 - 1; i > 0; i--) 
	{
		层 = 层管->图层s[i];
		x = mx - 层->vx0;
		y = my - 层->vy0;
		若 (0 <= x && x < 层->bx大小 && 0 <= y && y < 层->by大小) 
		{
			若 (层->buf[y * 层->bx大小 + x] != 层->col_inv) 
			{
				返回 层;
			}
		}
	}
	返回 0;
}
