/* ver指令(控制台.乙)  */
/* 作者 : 邵世雄 */
#定义 火龙_版本1	"ssxos Ver.0.1.05\n"
#定义 火龙_版本2	"Copy右(C) 2006-2007 Akkiesoft.\n\n"

/* asm头.nas */
结构 启动信息 { /* 0x0ff0-0x0fff */
	字符 cyls; /* 启动区读硬盘读到何处为止 */
	字符 键盘灯状态; /* 启动时键盘LED的状态 */
	字符 显卡模式; /* 显卡模式为多少位色彩 */
	字符 reserve;
	短整型 屏幕横坐标, 屏幕纵坐标; /* 画面分辨率 */
	无符号 字符 *显存;
};
#定义 地址_启动信息	0x00000ff0
#定义 地址_磁盘镜像		0x00100000

/* naskfunc.nas */
空 io_hlt(空);
空 io_cli(空);
空 io_sti(空);
空 io_stihlt(空);
整型 io_in8(整型 port);
空 io_out8(整型 port, 整型 数据);
整型 io_加载_e标记s(空);
空 io_store_e标记s(整型 e标记s);
空 加载_gdtr(整型 limit, 整型 添加r);
空 加载_idtr(整型 limit, 整型 添加r);
整型 加载_cr0(空);
空 store_cr0(整型 cr0);
空 加载_tr(整型 tr);
空 asm_inthandler0c(空);
空 asm_inthandler0d(空);
空 asm_inthandler20(空);
空 asm_inthandler21(空);
空 asm_inthandler27(空);
空 asm_inthandler2c(空);
无符号 整型 memtest_sub(无符号 整型 开始, 无符号 整型 结束);
空 farjmp(整型 eip, 整型 cs);
空 farcall(整型 eip, 整型 cs);
空 asm_火龙_api(空);
空 start_应用(整型 eip, 整型 cs, 整型 esp, 整型 ds, 整型 *tss_esp0);
空 asm_end_应用(空);

/* 进出.c */
结构 先进先出32 {
	整型 *buf;
	整型 p, q, 大小, 可用, 标记;
	结构 任务 *任;
};
空 进出32_初始化(结构 先进先出32 *进出, 整型 大小, 整型 *buf, 结构 任务 *任);
整型 进出32_放入(结构 先进先出32 *进出, 整型 数据);
整型 进出32_获取(结构 先进先出32 *进出);
整型 进出32_状态(结构 先进先出32 *进出);

/* graphic.c */
空 初始化_调色板(空);
空 设置_调色板(整型 开始, 整型 结束, 无符号 字符 *红绿蓝);
整型 获取_bpp(空);
整型 获取_颜色(整型 bpp, 整型 col);
空 实体盒(无符号 整型 *显存, 整型 x大小, 整型 c, 整型 x0, 整型 y0, 整型 x1, 整型 y1);
空 初始化_屏幕(无符号 整型 *显存, 整型 x, 整型 y);
空 打印字体(无符号 整型 *显存, 整型 x大小, 整型 x, 整型 y, 整型 c, 字符 *字体);
空 打印字体s(无符号 整型 *显存, 整型 x大小, 整型 x, 整型 y, 整型 c, 无符号 字符 *s);
空 初始化_鼠标_指针(无符号 整型 *鼠标, 整型 bc);
空 打印迷你字体(无符号 整型 *显存, 整型 x大小, 整型 x, 整型 y, 整型 c, 字符 *字体);
空 打印迷你字体s(无符号 整型 *显存, 整型 x大小, 整型 x, 整型 y, 整型 c, 无符号 字符 *s);
空 pic数据(无符号 整型 *显存, 整型 x大小, 整型 px, 整型 py, 无符号 字符 *数据, 整型 sx, 整型 sy, 整型 bc);

/* dsctbl.c */
结构 SEGMENT_DESCRIPTOR {
	短整型 limit_低, base_低;
	字符 base_中, access_右;
	字符 limit_高, base_高;
};
结构 GATE_DESCRIPTOR {
	短整型 off设置_低, selector;
	字符 dw_计数, access_右;
	短整型 off设置_高;
};
空 初始化_gdtidt(空);
空 设置_segmdesc(结构 SEGMENT_DESCRIPTOR *sd, 无符号 整型 limit, 整型 base, 整型 ar);
空 设置_gatedesc(结构 GATE_DESCRIPTOR *gd, 整型 offset, 整型 selector, 整型 ar);
#定义 地址_IDT			0x0026f800
#定义 限制_IDT		0x000007ff
#定义 地址_GDT			0x00270000
#定义 限制_GDT		0x0000ffff
#定义 地址_BOTPAK		0x00280000
#定义 限制_BOTPAK	0x0007ffff
#定义 AR_DATA32_RW	0x4092
#定义 AR_CODE32_ER	0x409a
#定义 AR_LDT			0x0082
#定义 AR_TSS32		0x0089
#定义 AR_INTGATE32	0x008e

/* 整型.c */
空 初始化_pic(空);
#定义 PIC0_ICW1		0x0020
#定义 PIC0_OCW2		0x0020
#定义 PIC0_IMR		0x0021
#定义 PIC0_ICW2		0x0021
#定义 PIC0_ICW3		0x0021
#定义 PIC0_ICW4		0x0021
#定义 PIC1_ICW1		0x00a0
#定义 PIC1_OCW2		0x00a0
#定义 PIC1_IMR		0x00a1
#定义 PIC1_ICW2		0x00a1
#定义 PIC1_ICW3		0x00a1
#定义 PIC1_ICW4		0x00a1

/* 键盘.c */
空 inthandler21(整型 *esp);
空 wait_KBC_sendready(空);
空 初始化_键盘(结构 先进先出32 *进出, 整型 数据0);
#定义 PORT_KEYDAT		0x0060
#定义 PORT_KEYCMD		0x0064

/* 鼠标.c */
结构 鼠标_DEC {
	无符号 字符 buf[3], phase;
	整型 x, y, btn;
};
空 启用_鼠标(结构 先进先出32 *进出, 整型 数据0, 结构 鼠标_DEC *mdec);
整型 鼠标_解码(结构 鼠标_DEC *mdec, 无符号 字符 dat);

/* 内存管理.c */
#定义 内存管理_FREES 	4090 		/* 大约是32kb */
#定义 内存管理_地址		0x003c0000	/* 内存管理地址 */
结构 可用信息 { /* 可用信息 */
	无符号 整型 添加r, 大小;
};
结构 内存管理 {	/* 内存管理 */
	整型 可用s, max可用s, lost大小, losts;
	结构 可用信息 可用[内存管理_FREES];
};
无符号 整型 memtest(无符号 整型 开始, 无符号 整型 结束);
空 内管_初始化(结构 内存管理 *内管);
无符号 整型 内管_总计(结构 内存管理 *内管);
无符号 整型 内管_分配(结构 内存管理 *内管, 无符号 整型 大小);
整型 内管_可用(结构 内存管理 *内管, 无符号 整型 添加r, 无符号 整型 大小);
无符号 整型 内管_分配_4k(结构 内存管理 *内管, 无符号 整型 大小);
整型 内管_可用_4k(结构 内存管理 *内管, 无符号 整型 添加r, 无符号 整型 大小);

/* 图层管理.c */
#定义 最大值_图层S 256
结构 图层 {
	无符号 字符 *buf, *窗体名称;
	整型 bx大小, by大小, vx0, vy0, col_inv, 高度, 标记, min_id;
	结构 图层管理 *层管;
	结构 任务 *任;
};
结构 图层管理 {
	无符号 字符 *显存, *网格;
	整型 x大小, y大小, 顶;
	结构 图层 *图层s[最大值_图层S];
	结构 图层 图层s0[最大值_图层S];
};
结构 图层管理 *层管_初始化(结构 内存管理 *内管, 无符号 字符 *显存, 整型 x大小, 整型 y大小);
结构 图层 *图层_分配(结构 图层管理 *层管);
空 图层_设置buf(结构 图层 *层, 无符号 字符 *buf, 整型 sx, 整型 sy, 整型 bgcol);
空 图层_上下(结构 图层 *层, 整型 高度);
空 图层_刷新(结构 图层 *层, 整型 bx0, 整型 by0, 整型 bx1, 整型 by1);
空 图层_位置(结构 图层 *层, 整型 vx0, 整型 vy0);
空 图层_可用(结构 图层 *层);

/* 定时器.c */
#定义 最大值_定时器	500
结构 定时器 {
	结构 定时器 *下一个;
	无符号 整型 超时;
	字符 标记, 标记2;
	结构 先进先出32 *进出;
	整型 数据;
};
结构 定时器管理 {
	无符号 整型 计数, 下一个;
	结构 定时器 *t0;
	结构 定时器 *定时s0;
};
外部 结构 定时器管理 定管;
空 初始化_pit(空);
空 初始化_定管(空);
结构 定时器 *定时_分配(空);
空 定时_可用(结构 定时器 *定时);
空 定时_初始化(结构 定时器 *定时, 结构 先进先出32 *进出, 整型 数据);
空 定时_设置时间(结构 定时器 *定时, 无符号 整型 超时);
整型 定时_取消(结构 定时器 *定时);
空 定时_取消所有(结构 先进先出32 *进出);
空 inthandler20(整型 *esp);

/* 多任务.c */
#定义 最大值_任务S		1000		/* 最大任务数量 */
#定义 最大值_任务S_LV	100			/* 每1Lv的任务数量 */
#定义 最大值_任务级别S	10			/* 级别数 */
#定义 任务_GDT0		3			/* 定义从GDT的几号start分配给TSS */
结构 TSS32 {
	整型 底层link, esp0, ss0, esp1, ss1, esp2, ss2, cr3;
	整型 eip, e标记s, eax, ecx, edx, ebx, esp, ebp, esi, edi;
	整型 es, cs, ss, ds, fs, gs;
	整型 ldtr, io网格;
};
结构 任务 {
	整型 sel, 标记;	/* sel用来存放GDT的编号 */
	整型 级别, 优先;
	结构 先进先出32 进出;
	结构 TSS32 tss;
	结构 SEGMENT_DESCRIPTOR ldt[2];
	结构 控制台 *控制台;
	整型 ds_base, 控制台_stack;
	结构 文件句柄 *文件句柄;
	整型 *文件分配表;
	字符 *命令行;
	无符号 字符 语言模式0, 语言模式, 语言字节1;
	字符 *标题栏;
};
结构 任务级别 {
	整型 正在运行;	 /* 正在运行的任务数量 */
	整型 当前;		/* 这个变量用来记录当前正在运行的是哪个任务 */
	结构 任务 *任s[最大值_任务S_LV];
};
结构 任务管理 {
	整型 当前_lv;		/* 现在活动中的级别 */
	字符 lv_改变;	/* 在下次任务切换时是否需要改变级别 */
	结构 任务级别 级别[最大值_任务级别S];
	结构 任务 任s0[最大值_任务S];
};
外部 结构 任务管理 *任管;
外部 结构 定时器 *任_定时;
结构 任务 *任_当前(空);
结构 任务 *任_初始化(结构 内存管理 *内管);
结构 任务 *任_分配(空);
空 任_运行(结构 任务 *任, 整型 级别, 整型 优先);
空 任_切换(空);
空 任_睡眠(结构 任务 *任);

/* 窗体.c */
结构 气泡 {
	结构 图层 *层;
	整型 px, py, s模式, sx, sy;
};
空 制作_窗体(无符号 整型 *buf, 整型 x大小, 整型 y大小, 字符 *标题, 整型 icon, 字符 act);
空 制作_窗口标题(无符号 整型 *buf, 整型 x大小, 字符 *标题, 整型 icon, 字符 act);
空 制作_文本框(结构 图层 *层, 整型 x0, 整型 y0, 整型 sx, 整型 sy, 整型 c);
空 打印字体s_asc_层(结构 图层 *层, 整型 x, 整型 y, 整型 c, 整型 b, 字符 *s, 整型 l);
空 改变_窗口标题(结构 图层 *层, 整型 act);
结构 气泡 *制作_泡(结构 内存管理 *内管, 结构 图层 *层,
								整型 px, 整型 py, 整型 s模式, 整型 sx, 整型 sy);
空 打印迷你字体s_asc_层(结构 图层 *层, 整型 x, 整型 y, 整型 c, 整型 b, 字符 *s, 整型 l);
空 制作_omnaomi(结构 图层 *层, 整型 px, 整型 py);

/* 控制台.c */
结构 控制台 {
	结构 图层 *层;
	整型 curx, cury, curcol;
	结构 定时器 *定时;
};
结构 文件句柄 {
	字符 *buf;
	整型 大小;
	整型 pos;
};
空 控制台_任(结构 图层 *图层, 整型 内存总计);
空 控制台_放入字符(结构 控制台 *控制台, 整型 chr, 字符 move);
空 控制台_放入str0(结构 控制台 *控制台, 字符 *s);
空 控制台_放入str1(结构 控制台 *控制台, 字符 *s, 整型 l);
空 控制台_新行(结构 控制台 *控制台);
空 控制台_recent(结构 控制台 *控制台, 字符 *命令行, 整型 n);
空 控制台_运行命令(字符 *命令行, 结构 控制台 *控制台, 整型 *文件分配表, 整型 内存总计);
空 命令_mem(结构 控制台 *控制台, 整型 内存总计);
空 命令_cls(结构 控制台 *控制台);
空 命令_dir(结构 控制台 *控制台, 字符 *命令行, 整型 *文件分配表);
空 命令_exit(结构 控制台 *控制台, 整型 *文件分配表);
空 命令_start(结构 控制台 *控制台, 字符 *命令行, 整型 内存总计);
空 命令_ncst(结构 控制台 *控制台, 字符 *命令行, 整型 内存总计);
空 命令_语言模式(结构 控制台 *控制台, 字符 *命令行);
空 命令_reboot(结构 控制台 *控制台);
空 命令_ver(结构 控制台 *控制台);
空 命令_history(结构 控制台 *控制台, 字符 *命令行);
空 命令_墙纸paper(结构 控制台 *控制台, 字符 *命令行, 整型 *文件分配表);
空 命令_时间(结构 控制台 *控制台);
空 命令_jpfont(结构 控制台 *控制台, 字符 *命令行, 整型 *文件分配表);
整型 命令_应用(结构 控制台 *控制台, 整型 *文件分配表, 字符 *命令行);
整型 *inthandler0c(整型 *esp);
整型 *inthandler0d(整型 *esp);

/* 文件管理.c */
结构 文件信息 {
	无符号 字符 名称[8], ext[3], 类型;
	字符 reserve[10];
	无符号 短整型 时间, date, clustno;
	无符号 整型 大小;
};
空 文件_读取文件分配表(整型 *文件分配表, 无符号 字符 *img);
空 文件_加载文件(整型 clustno, 整型 大小, 字符 *buf, 整型 *文件分配表, 字符 *img);
字符 *文件_加载文件2(整型 clustno, 整型 *p大小, 整型 *文件分配表);
结构 文件信息 *文件_搜索(字符 *名称, 结构 文件信息 *文信, 整型 max);

/* 压缩算法.c */
整型 tek_获取大小(无符号 字符 *p);
整型 tek_decomp(无符号 字符 *p, 字符 *q, 整型 大小);

/* 主程序.c */
#定义 最大值_MINID 256
#定义 控制台_SIZEX	680
#定义 控制台_SIZEY	420
结构 任务 *打开_控制台任务(结构 图层 *层, 无符号 整型 内存总计);
结构 图层 *打开_控制台(结构 图层管理 *层管, 无符号 整型 内存总计);
空 键窗_off(结构 图层 *键_窗);
空 键窗_on(结构 图层 *键_窗);

/* 描绘.c */
结构 DLL_STRPICENV {	/* 64KB */
	整型 work[64 * 1024 / 4];
};
结构 红绿蓝 {
	无符号 字符 b, g, r, t;
};
结构 绘画 {
	字符 *名称, *文件buf;
	结构 红绿蓝 *picbuf;
	结构 DLL_STRPICENV *env;
	整型 f大小, 错, 信息[8];
	/* 
		错 list
		1: File not found.
		2: File is not image.
	 */
};
整型 描绘_信息(结构 DLL_STRPICENV *env, 整型 *信息, 整型 大小, 字符 *fp);
整型 描绘_解码0(整型 模式, 结构 DLL_STRPICENV *env, 整型 大小,
					 字符 *fp, 整型 b_类型, 字符 *buf, 整型 跳过);
无符号 字符 红绿蓝2pal(整型 r, 整型 g, 整型 b, 整型 x, 整型 y);
结构 绘画 *描绘_初始化(字符 *名称, 整型 *文件分配表);
整型 描绘_画(结构 图层 *层, 结构 绘画 *pic, 整型 px, 整型 py);
空 描绘_可用(结构 绘画 *pic);

/* 位图解码 */
整型 info_BMP(结构 DLL_STRPICENV *env, 整型 *信息, 整型 大小, 字符 *fp);
整型 decode0_BMP(结构 DLL_STRPICENV *env, 整型 大小, 字符 *fp, 整型 b_类型, 字符 *buf, 整型 跳过);

/* 联像组解码.c */
整型 信息_联像组(结构 DLL_STRPICENV *env, 整型 *信息, 整型 大小, 字符 *fp);
整型 解码0_联像组(结构 DLL_STRPICENV *env, 整型 大小, 字符 *fp, 整型 b_类型, 字符 *buf, 整型 跳过);

/* 图标解码.c */
整型 信息_图标(结构 DLL_STRPICENV *env, 整型 *信息, 整型 大小, 字符 *fp);
整型 解码0_图标(结构 DLL_STRPICENV *env, 整型 大小, 字符 *fp, 整型 b_类型, 字符 *buf, 整型 跳过);

/* 应用程序接口.乙 */
整型 *火龙_api(整型 edi, 整型 esi, 整型 ebp, 整型 esp, 整型 ebx, 整型 edx, 整型 ecx, 整型 eax);
空 火龙_api_li新in(结构 图层 *层, 整型 x0, 整型 y0, 整型 x1, 整型 y1, 整型 col);
结构 系统_信息 {
	无符号 字符 cyls;     /* 引导扇区读取磁盘的距离 */
	无符号 字符 键盘灯状态;     /* 启动时键盘LED状态 */
	无符号 字符 显卡模式;     /* 视频模式多少位颜色 */
	无符号 字符 reserve;  /* 预订 */
	无符号 短整型 屏幕横坐标; /* 画面解像度 */
	无符号 短整型 屏幕纵坐标; /* 画面解像度 */
	无符号 字符 *显存;    /* 显存的地址 */
	无符号 短整型 os_类型;  /* 操作系统类型 */
};
结构 时间_信息 {
	整型 年, 月, 日, 时, 分, 秒;
};
结构 鼠标_信息 {
	整型 x, y;
};

/* 实时时钟.乙 */
整型 rtc_获取(整型 类型);
