; 甲语言函数
; 制表符=4
; 作者：邵世雄

[格式 "WCOFF"]				;  制作目标文件的模式
[命令模式 "i486p"]			; 使用486命令的记述
[位 32]						; 制作32位模式用的机器语言
[文件名 "甲语言函数.甲"]	; 源文件名信息

		全局	_出入流_暂停, _出入流_禁中断, _出入流_许中断, _出入流_许中断暂停
		全局	_出入流_输入8,  _出入流_输入16,  _出入流_输入32
		全局	_出入流_输出8, _出入流_输出16, _出入流_输出32
		全局	_出入流_加载_efla全段寄, _出入流_st或e_efla全段寄
		全局	_加载_gdtr, _加载_idtr
		全局	_加载_cr0, _st或e_cr0
		全局	_加载_tr
		全局	_甲语言_中断h与ler20, _甲语言_中断h与ler21, _甲语言_中断h与ler27
		全局	_甲语言_中断h与ler2c, _甲语言_中断h与ler0c, _甲语言_中断h与ler0d
		全局	_内存t附段寄t_减法
		全局	_远距跳转, _远距调用
		全局	_甲语言_火龙_应用程序接口, _甲语言_结束_应用, _开始_应用
		外部	_中断h与ler20, _中断h与ler21, _中断h与ler27
		外部	_中断h与ler2c, _中断h与ler0c, _中断h与ler0d
		外部	_火龙_应用程序接口
		全局	__分配a

[段 .text] ; 目标文件中写了这些之后再写程序

_出入流_暂停:	; 空 出入流_暂停(空);
		暂停
		返回

_出入流_禁中断:	; 空 出入流_禁中断(空);
		禁中断
		返回

_出入流_许中断:	; 空 出入流_许中断(空);
		许中断
		返回

_出入流_许中断暂停:	; 空 出入流_许中断暂停(空);
		许中断
		暂停
		返回

_出入流_输入8:	; 中断 出入流_输入8(中断 p或t);
		传送		扩数寄,[扩栈寄+4]		; p或t
		传送		扩加寄,0
		输入		加低,数寄
		返回

_出入流_输入16:	; 中断 出入流_输入16(中断 p或t);
		传送		扩数寄,[扩栈寄+4]		; p或t
		传送		扩加寄,0
		输入		加寄,数寄
		返回

_出入流_输入32:	; 中断 出入流_输入32(中断 p或t);
		传送		扩数寄,[扩栈寄+4]		; p或t
		输入		扩加寄,数寄
		返回

_出入流_输出8:	; 空 出入流_输出8(中断 p或t, 中断 数据);
		传送		扩数寄,[扩栈寄+4]		; p或t
		传送		加低,[扩栈寄+8]		; 数据
		输出		数寄,加低
		返回

_出入流_输出16:	; 空 出入流_输出16(中断 p或t, 中断 数据);
		传送		扩数寄,[扩栈寄+4]		; p或t
		传送		扩加寄,[扩栈寄+8]		; 数据
		输出		数寄,加寄
		返回

_出入流_输出32:	; 空 出入流_输出32(中断 p或t, 中断 数据);
		传送		扩数寄,[扩栈寄+4]		; p或t
		传送		扩加寄,[扩栈寄+8]		; 数据
		输出		数寄,扩加寄
		返回

_出入流_加载_efla全段寄:	; 中断 出入流_加载_efla全段寄(空);
		入栈fd		; 入栈 efla全段寄 
		出栈		扩加寄
		返回

_出入流_st或e_efla全段寄:	; 空 出入流_st或e_efla全段寄(中断 efla全段寄);
		传送		扩加寄,[扩栈寄+4]
		入栈		扩加寄
		出栈fd		; 出栈 efla全段寄  
		返回

_加载_gdtr:		; 空 加载_gdtr(中断 限定, 中断 加法r);
		传送		加寄,[扩栈寄+4]		; 限定
		传送		[扩栈寄+6],加寄
		全局表		[扩栈寄+6]
		返回

_加载_idtr:		; 空 加载_idtr(中断 限定, 中断 加法r);
		传送		加寄,[扩栈寄+4]		; 限定
		传送		[扩栈寄+6],加寄
		lidt		[扩栈寄+6]
		返回

_加载_cr0:		; 中断 加载_cr0(空);
		传送		扩加寄,cr0
		返回

_st或e_cr0:		; 空 st或e_cr0(中断 cr0);
		传送		扩加寄,[扩栈寄+4]
		传送		cr0,扩加寄
		返回

_加载_tr:		; 空 加载_tr(中断 tr);
		ltr			[扩栈寄+4]		; tr
		返回

_甲语言_中断h与ler20:
		入栈		附段寄
		入栈		数段寄
		入栈ad
		传送		扩加寄,扩栈寄
		入栈		扩加寄
		传送		加寄,栈段寄
		传送		数段寄,加寄
		传送		附段寄,加寄
		调用		_中断h与ler20
		出栈		扩加寄
		出栈ad
		出栈		数段寄
		出栈		附段寄
		中断返回

_甲语言_中断h与ler21:
		入栈		附段寄
		入栈		数段寄
		入栈ad
		传送		扩加寄,扩栈寄
		入栈		扩加寄
		传送		加寄,栈段寄
		传送		数段寄,加寄
		传送		附段寄,加寄
		调用		_中断h与ler21
		出栈		扩加寄
		出栈ad
		出栈		数段寄
		出栈		附段寄
		中断返回

_甲语言_中断h与ler27:   ; （这几乎与_asm_输入thorler20等相同。）
        入栈     	附段寄
        入栈     	数段寄
        入栈ad
        传送     	扩加寄,扩栈寄
        入栈     	扩加寄
        传送     	加寄,栈段寄
        传送     	数段寄,加寄
        传送     	附段寄,加寄
        调用    	_中断h与ler27
        出栈     	扩加寄
        出栈ad
        出栈     	数段寄
        出栈     	附段寄
        中断返回

_甲语言_中断h与ler2c:
		入栈		附段寄
		入栈		数段寄
		入栈ad
		传送		扩加寄,扩栈寄
		入栈		扩加寄
		传送		加寄,栈段寄
		传送		数段寄,加寄
		传送		附段寄,加寄
		调用		_中断h与ler2c
		出栈		扩加寄
		出栈ad
		出栈		数段寄
		出栈		附段寄
		中断返回

_甲语言_中断h与ler0c:
		许中断
		入栈		附段寄
		入栈		数段寄
		入栈ad
		传送		扩加寄,扩栈寄
		入栈		扩加寄
		传送		加寄,栈段寄
		传送		数段寄,加寄
		传送		附段寄,加寄
		调用		_中断h与ler0c
		比较		扩加寄,0
		不等零		_甲语言_结束_应用
		出栈		扩加寄
		出栈ad
		出栈		数段寄
		出栈		附段寄
		加法		扩栈寄,4			;输入T 0x0c 中也需要这句
		中断返回

_甲语言_中断h与ler0d:
		许中断
		入栈		附段寄
		入栈		数段寄
		入栈ad
		传送		扩加寄,扩栈寄
		入栈	    扩加寄
		传送		加寄,栈段寄
		传送		数段寄,加寄
		传送		附段寄,加寄
		调用	    _中断h与ler0d
		比较		扩加寄,0
		不等零		_甲语言_结束_应用
		出栈		扩加寄
		出栈ad
		出栈		数段寄
		出栈		附段寄
		加法		扩栈寄,4			; 在输入T 0x0d 中需要这句
		中断返回

_内存t附段寄t_减法:	; 无符号 中断 内存t附段寄t_减法(无符号 中断 开始, 无符号 中断 结束)
		入栈		扩终寄
		入栈		扩源寄
		入栈		扩基寄
		传送		扩源寄,0xaa55aa55			; pat0
		传送		扩终寄,0x55aa55aa			; pat1
		传送		扩加寄,[扩栈寄+12+4]			; i = 开始;
mts_loop:
		传送		扩基寄,扩加寄
		加法		扩基寄,0xffc				; p = i + 0xffc;
		传送		扩数寄,[扩基寄]				; 旧 = *p;
		传送		[扩基寄],扩源寄				; *p = pat0;
		异或		双字 [扩基寄],0xffffffff	; *p ^= 0xffffffff;
		比较		扩终寄,[扩基寄]				; 若 (pat1 != *p)
		不等零		mts_f输入					;	转到 f输入;
		异或		双字 [扩基寄],0xffffffff	; *p ^= 0xffffffff;
		比较		扩源寄,[扩基寄]				; 若 (pat0 != *p)
		不等零		mts_f输入					;	转到 f输入;
		传送		[扩基寄],扩数寄				; *p = 旧;
		加法		扩加寄,0x1000				; i += 0x1000;
		比较		扩加寄,[扩栈寄+12+8]			; 若 (i <= 结束)
		小于等于		mts_loop				;	转到 mts_loop
		出栈		扩基寄
		出栈		扩源寄
		出栈		扩终寄
		返回
mts_f输入:
		传送		[扩基寄],扩数寄				; *p = 旧;
		出栈		扩基寄
		出栈		扩源寄
		出栈		扩终寄
		返回

_远距跳转:		; 空 远距跳转(中断 eip, 中断 cs);
		跳转		远距[扩栈寄+4]		; eip, cs
		返回

_远距调用:		; 空 远距调用(中断 eip, 中断 cs);
		调用		远距[扩栈寄+4]		; eip, cs
		返回

_甲语言_火龙_应用程序接口:
		许中断
		入栈		数段寄
		入栈		附段寄
		入栈ad					; 用于保存寄存器值的PUSH
		入栈ad					; 用于向火龙_api传值的PUSH
		传送		加寄,栈段寄
		传送		数段寄,加寄			; 将操作系统用段地址存入DB和ES
		传送		附段寄,加寄
		调用		_火龙_应用程序接口
		比较		扩加寄,0			; 当EAX不为0时程序结束
		不等零		_甲语言_结束_应用
		加法		扩栈寄,32
		出栈ad
		出栈		附段寄
		出栈		数段寄
		中断返回
_甲语言_结束_应用:
;	Tsukayoro是t-dandan。
		传送		扩栈寄,[扩加寄]
		传送		双字 [扩加寄+4],0
		出栈ad
		返回						; 返回cmd_应用

_开始_应用:		; 空 开始_应用(中断 eip, 中断 cs, 中断 扩栈寄, 中断 数段寄, 中断 *t栈段寄_扩栈寄0);
		入栈ad					; 将32位寄存器的值全部保存下来
		传送		扩加寄,[扩栈寄+36]	; 应用程序用EIP
		传送		扩计寄,[扩栈寄+40]	; 应用程序用CS
		传送		扩数寄,[扩栈寄+44]	; 应用程序用ESP
		传送		扩基寄,[扩栈寄+48]	; 应用程序用DS/SS
		传送		扩址寄,[扩栈寄+52]	; tss.esp0的地址
		传送		[扩址寄  ],扩栈寄		; 保存操作系统用ESP
		传送		[扩址寄+4],栈段寄		; 保存操作系统用SS
		传送		附段寄,基寄
		传送		数段寄,基寄
		传送		标段寄,基寄
		传送		全段寄,基寄
; 下面调整栈，以免用RETF跳转到应用程序
		或			扩计寄,3			;  将应用程序用段号和3进行OR运算
		或			扩基寄,3			; 将应用程序用段号和3进行OR运算
		入栈		扩基寄				; 应用程序的SS
		入栈		扩数寄				; 应用程序的ESP
		入栈		扩计寄				; 应用程序的CS
		入栈		扩加寄				; 应用程序的EIP
		返回码段

__分配a:
		加法		扩加寄,-4
		减法		扩栈寄,扩加寄
		跳转		双字 [扩栈寄+扩加寄]		; 返回替代
