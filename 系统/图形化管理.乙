/* 图像处理相关的 */
/* 作者 : 邵世雄 */
#引入 "主程序.头"

静态 无符号 字符 表_红绿蓝[16 * 3] = {
	0x00, 0x00, 0x00,	/*  0:黑 */
		0xff, 0x00, 0x00,	/*  1:亮红 */
		0x00, 0xff, 0x00,	/*  2:亮绿 */
		0xff, 0xff, 0x00,	/*  3:亮黄 */
		0x00, 0x00, 0xff,	/*  4:亮蓝 */
		0xff, 0x00, 0xff,	/*  5:亮紫 */
		0x00, 0xff, 0xff,	/*  6:浅亮蓝 */
		0xff, 0xff, 0xff,	/*  7:白 */
		0xc6, 0xc6, 0xc6,	/*  8:亮灰 */
		0x84, 0x00, 0x00,	/*  9:暗红 */
		0x00, 0x84, 0x00,	/* 10:暗绿 */
		0x84, 0x84, 0x00,	/* 11:暗黄 */
		0x00, 0x00, 0x84,	/* 12:暗青 */
		0x84, 0x00, 0x84,	/* 13:暗紫 */
		0x00, 0x84, 0x84,	/* 14:浅暗蓝 */
		0x84, 0x84, 0x84	/* 15:暗灰 */
};
静态 无符号 字符 表_红绿蓝_火龙[2 * 3] = {
	/* ssxos Only */
	0x3a, 0x6e, 0xa5,	/* 240:WinXP背景颜色 */
	0x00, 0x80, 0xff	/* 241:标题栏 */
};

空 初始化_调色板(空)
{
	无符号 字符 表_红绿蓝2[216 * 3];

	若 (获取_像素深度() != 8) 
	{
		/* 不是8位色彩的就返回 */
		返回;
	}

	整型 r, g, b, i;
	循环 (b = 0; b < 6; b++) 
	{
		循环 (g = 0; g < 6; g++) 
		{
			循环 (r = 0; r < 6; r++) 
			{
				i = (r + g * 6 + b* 36) * 3;
				表_红绿蓝2[i    ] = r * 51;
				表_红绿蓝2[i + 1] = g * 51;
				表_红绿蓝2[i + 2] = b * 51;
			}
		}
	}
	设置_调色板(0, 15, 表_红绿蓝);
	设置_调色板(16, 231, 表_红绿蓝2);
	设置_调色板(240, 241, 表_红绿蓝_火龙);
	返回;

	/*  静态 字符 命令 数据以外不能使用,不过，DB 命令相当 */
}

空 设置_调色板(整型 开始, 整型 结束, 无符号 字符 *红绿蓝)
{
	整型 i, e标记s;
	e标记s = 出入流_加载_e标记s();	/* 记录中断许可标志的值 */
	出入流_cli(); 					/* 将中断许可标志置为0，禁止中断 */
	出入流_out8(0x03c8, 开始);
	循环 (i = 开始; i <= 结束; i++) 
	{
		出入流_out8(0x03c9, 红绿蓝[0] / 4);
		出入流_out8(0x03c9, 红绿蓝[1] / 4);
		出入流_out8(0x03c9, 红绿蓝[2] / 4);
		红绿蓝 += 3;
	}
	出入流_store_e标记s(e标记s);	/* 复原中断许可标志 */
	返回;
}

整型 获取_像素深度(空)
{
	结构 启动信息 *启信 = (结构 启动信息 *) 地址_启动信息;
	返回 启信->显卡模式;
}

整型 获取_颜色(整型 像素深度, 整型 col)
{
	/* 0x……转换成各种字节色码 */
	/* 此函数仅在最下层函数中使用 */
	结构 启动信息 *启信 = (结构 启动信息 *) 地址_启动信息;
	整型 i = 0, r, g, b;
	静态 无符号 整型 pallet[16] = {
		0x000000, 0xff0000, 0x00ff00, 0xffff00, 0x0000ff, 0xff00ff, 0x00ffff, 0xffffff, 
		0xc6c6c6, 0x840000, 0x008400, 0x848400, 0x000084, 0x840084, 0x008484, 0x848484
	};
	若 (像素深度 == 0) 
	{
		像素深度 = 启信->显卡模式;
	}
	若 (像素深度 == 1) 
	{
		/* 将8bit 号码转换为0x……格式 */
		若 (0 <= col && col <= 15) 
		{
			/* 16色 */
			循环 (i = 0; i < 16; i++) 
			{
				若 (col == i) 
				{
					i = pallet[i];
					终止;
				}
			}
		} 则 若 (16 <= col && col <= 231) 
		{
			/* 216色 */
			循环 (b = 0; b < 6; b++) 
			{
				循环 (g = 0; g < 6; g++) 
				{
					循环 (r = 0; r < 6; r++) 
					{
						若 ((16 + r + g * 6 + b* 36) == col) 
						{
							i = (r << 16) | (g << 8) | b;
							转到 跳过;
						}
					}
				}
			}
		} 
		则 
		{
			/* SSXOS颜色 */
			若 (col == 240) { i = 0x3a6ea5; } 则
			若 (col == 241) { i = 0x0080ff; }
		}
	} 
	则 若 (像素深度 == 8) 
	{
		循环 (i = 0; i < 16; i++) 
		{
			若 (col == pallet[i]) { 转到 跳过; }
		}
		/* SSXOS颜色 */
		若 (col == 0x3a6ea5) { i = 240; } 则
		若 (col == 0x0080ff) { i = 241; }
		则 
		{
			/*  216色(选择接近的颜色) */
			i = ((col >> 16) + ((col >> 8) & 0xff) + (col & 0xff)) / 51;
		}
	} 
	则 若 (像素深度 == 16) 
	{
		i = (((col >> 16) << 8) & 0xf800) | ((((col >> 8) & 0xff) << 3) & 0x07e0) | ((col & 0xff) >> 3);
	}
跳过:
	返回 i;
}


/* 8bit, 16位自动判断函数 ------------------------------------------ */

空 实体盒(无符号 整型 *显存, 整型 x大小, 整型 c, 整型 x0, 整型 y0, 整型 x1, 整型 y1)
{
	整型 像素深度, col, x, y;
	无符号 字符  *cp = (无符号 字符  *) 显存;
	无符号 短整型 *sp = (无符号 短整型 *) 显存;
	像素深度 = 获取_像素深度();
	col = 获取_颜色(像素深度, c);

	若 (像素深度 == 8) 
	{
		循环 (y = y0; y <= y1; y++) 
		{
			循环 (x = x0; x <= x1; x++)
				cp[y * x大小 + x] = col;
		}
	} 
	则 若 (像素深度 == 16) 
	{
		循环 (y = y0; y <= y1; y++) 
		{
			循环 (x = x0; x <= x1; x++)
				sp[y * x大小 + x] = col;
		}
	} 
	则 若 (像素深度 == 24) 
	{
		循环 (y = y0; y <= y1; y++) 
		{
			循环 (x = x0; x <= x1; x++)
				显存[y * x大小 + x] = col;
		}
	}
	返回;
}
 

空 初始化_屏幕(无符号 整型 *显存, 整型 x, 整型 y)
{
	实体盒(显存, x, 0x3a6ea5, 0, 0, x - 1, y - 1);	// 桌面背景
	

	 
	返回;
}

空 打印字体(无符号 整型 *显存, 整型 x大小, 整型 x, 整型 y, 整型 c, 字符 *字体)
{
	字符 d;	/* 数据 */
	整型 col, 像素深度, i;
	无符号 字符  *cp;
	无符号 短整型 *sp;
	无符号 整型   *ip;
	像素深度 = 获取_像素深度();
	col = 获取_颜色(像素深度, c);
	若 (像素深度 == 8) 
	{
		循环 (i = 0; i < 16; i++) 
		{
			cp = (无符号 字符 *) 显存 + (y + i) * x大小 + x;
			d = 字体[i];
			若 ((d & 0x80) != 0) { cp[0] = col; }
			若 ((d & 0x40) != 0) { cp[1] = col; }
			若 ((d & 0x20) != 0) { cp[2] = col; }
			若 ((d & 0x10) != 0) { cp[3] = col; }
			若 ((d & 0x08) != 0) { cp[4] = col; }
			若 ((d & 0x04) != 0) { cp[5] = col; }
			若 ((d & 0x02) != 0) { cp[6] = col; }
			若 ((d & 0x01) != 0) { cp[7] = col; }
		}
	} 
	则 若 (像素深度 == 16) {
		循环 (i = 0; i < 16; i++) 
		{
			sp = (无符号 短整型 *) 显存 + (y + i) * x大小 + x;
			d = 字体[i];
			若 ((d & 0x80) != 0) { sp[0] = col; }
			若 ((d & 0x40) != 0) { sp[1] = col; }
			若 ((d & 0x20) != 0) { sp[2] = col; }
			若 ((d & 0x10) != 0) { sp[3] = col; }
			若 ((d & 0x08) != 0) { sp[4] = col; }
			若 ((d & 0x04) != 0) { sp[5] = col; }
			若 ((d & 0x02) != 0) { sp[6] = col; }
			若 ((d & 0x01) != 0) { sp[7] = col; }
		}
	} 
	则 若 (像素深度 == 24) 
	{
		循环 (i = 0; i < 16; i++) 
		{
			ip = 显存 + (y + i) * x大小 + x;
			d = 字体[i];
			若 ((d & 0x80) != 0) { ip[0] = col; }
			若 ((d & 0x40) != 0) { ip[1] = col; }
			若 ((d & 0x20) != 0) { ip[2] = col; }
			若 ((d & 0x10) != 0) { ip[3] = col; }
			若 ((d & 0x08) != 0) { ip[4] = col; }
			若 ((d & 0x04) != 0) { ip[5] = col; }
			若 ((d & 0x02) != 0) { ip[6] = col; }
			若 ((d & 0x01) != 0) { ip[7] = col; }
		}
	}
	返回;
}

空 打印字体s(无符号 整型 *显存, 整型 x大小, 整型 x, 整型 y, 整型 c, 无符号 字符 *s)
{
	外部 字符 mhbm[4096];
	结构 任务 *任 = 任_当前();
	字符 *chinese = (字符 *) *((整型 *) 0x0fe8), *字体;
	整型 k, t;

	若 (任->语言模式 == 0) 
	{
		循环 (; *s != 0x00; s++) 
		{
			打印字体(显存, x大小, x, y, c, mhbm + *s * 16);
			x += 8;
		}
	}
	若 (任->语言模式 == 1) 
	{
		循环 (; *s != 0x00; s++) 
		{
			若 (任->语言字节1 == 0) 
			{
				/* 第一个字节 */
				若 ((0x81 <= *s && *s <= 0x9f) || (0xe0 <= *s && *s <= 0xfc)) 
				{
					/* 第2个字节（全角） */
					任->语言字节1 = *s;
				} 
				则 
				{
					 /* 半角文字 */
					打印字体(显存, x大小, x, y, c, chinese + *s * 16);
				}
			} 
			则 
			{
				/*第二个字节 */
				若 (0x81 <= 任->语言字节1 && 任->语言字节1 <= 0x9f) 
				{
					k = (任->语言字节1 - 0x81) * 2;
				} 
				则 
				{
					k = (任->语言字节1 - 0xe0) * 2 + 62;
				}
				若 (0x40 <= *s && *s <= 0x7e) 
				{
					t = *s - 0x40;		/*  较小的区(0x40～0x7e) */
				} 
				则 若 (0x80 <= *s && *s <= 0x9e) 
				{
					t = *s - 0x80 + 63;	/*  较小的区(0x80～0x9e) */
				} 
				则 
				{
					t = *s - 0x9f;		/* 较大的区(0x9f～0xfc) */
					k++;
				}
				任->语言字节1 = 0;
				字体 = chinese + 256 * 16 + (k * 94 + t) * 32;
				打印字体(显存, x大小, x - 8, y, c, 字体     );	/* 左侧 */
				打印字体(显存, x大小, x    , y, c, 字体 + 16);	/* 右侧 */
			}
			x += 8;
		}
	}
	若 (任->语言模式 == 2) 
	{
		循环 (; *s != 0x00; s++) 
		{
			若 (任->语言字节1 == 0) 
			{
				/* 第一个字节 */
				若 (0x81 <= *s && *s <= 0xfe) 
				{
					任->语言字节1 = *s;	/* 第2个字节（全角） */
				} 
				则 
				{
					打印字体(显存, x大小, x, y, c, chinese + *s * 16);	 /* 半角文字 */
				}
			} 
			则 
			{
				/*第二个字节 */
				k = 任->语言字节1 - 0xa1;
				t = *s - 0xa1;
				任->语言字节1 = 0;
				字体 = chinese + 256 * 16 + (k * 94 + t) * 32;
				打印字体(显存, x大小, x - 8, y, c, 字体     );	/* 左侧 */
				打印字体(显存, x大小, x    , y, c, 字体 + 16);	/* 右侧 */
			}
			x += 8;
		}
	}
	返回;
}

空 初始化_鼠标_指针(无符号 整型 *鼠标, 整型 bc)
{
	静态 无符号 字符 数据[16][16] = {
		   "aa..............",
        "aha.............",
        "ahha............",
        "ahhha...........",
        "ahhhha..........",
        "ahhhhha.........",
        "ahhhhhha........",
        "ahhhhhhha.......",
        "ahhhhhhhha......",
        "ahhhhhaaaaa.....",
        "ahhahha.........",
        "aha.ahha........",
        "aa..ahha........",
        "a....ahha.......",
        ".....ahha.......",
        "......aaa.......",
		".......aaa......"
	};
	pic数据(鼠标, 16, 0, 0, &数据[0][0], 16, 16, bc);
	返回;
}

空 打印迷你字体(无符号 整型 *显存, 整型 x大小, 整型 x, 整型 y, 整型 c, 字符 *字体)
{
	字符 d;	/* 数据 */
	整型 col, 像素深度, i;
	无符号 字符  *cp;
	无符号 短整型 *sp;
	无符号 整型   *ip;
	像素深度 = 获取_像素深度();
	col = 获取_颜色(像素深度, c);
	若 (像素深度 == 8) 
	{
		循环 (i = 0; i < 12; i++) 
		{
			cp = (无符号 字符 *) 显存 + (y + i) * x大小 + x;
			d = 字体[i];
			若 ((d & 0x20) != 0) { cp[0] = col; }
			若 ((d & 0x10) != 0) { cp[1] = col; }
			若 ((d & 0x08) != 0) { cp[2] = col; }
			若 ((d & 0x04) != 0) { cp[3] = col; }
			若 ((d & 0x02) != 0) { cp[4] = col; }
			若 ((d & 0x01) != 0) { cp[5] = col; }
		}
	} 
	则 若 (像素深度 == 16) 
	{
		循环 (i = 0; i < 12; i++) 
		{
			sp = (无符号 短整型 *) 显存 + (y + i) * x大小 + x;
			d = 字体[i];
			若 ((d & 0x20) != 0) { sp[0] = col; }
			若 ((d & 0x10) != 0) { sp[1] = col; }
			若 ((d & 0x08) != 0) { sp[2] = col; }
			若 ((d & 0x04) != 0) { sp[3] = col; }
			若 ((d & 0x02) != 0) { sp[4] = col; }
			若 ((d & 0x01) != 0) { sp[5] = col; }
		}
	} 
	则 若 (像素深度 == 24) 
	{
		循环 (i = 0; i < 12; i++) 
		{
			ip = 显存 + (y + i) * x大小 + x;
			d = 字体[i];
			若 ((d & 0x20) != 0) { ip[0] = col; }
			若 ((d & 0x10) != 0) { ip[1] = col; }
			若 ((d & 0x08) != 0) { ip[2] = col; }
			若 ((d & 0x04) != 0) { ip[3] = col; }
			若 ((d & 0x02) != 0) { ip[4] = col; }
			若 ((d & 0x01) != 0) { ip[5] = col; }
		}
	} 则 
	返回;
}

空 打印迷你字体s(无符号 整型 *显存, 整型 x大小, 整型 x, 整型 y, 整型 c, 无符号 字符 *s)
{
	外部 字符 mnbzk[4096];
	循环 (; *s != 0x00; s++) 
	{
		打印迷你字体(显存, x大小, x, y, c, mnbzk + *s * 12);
		x += 6;
	}
	返回;
}


// 空 放入_naomi(无符号 整型 *显存)
// {
	// 静态 无符号 字符 naomi[26][28] = {
		// "ooooooooooooaaaaoooooooooooo",
		// "oooooooooaaaddddaaaooooooooo",
		// "ooooooooaddddddddddaoooooooo",
		// "oooooooaddddddddddddaooooooo",
		// "ooooooaddddddddddddddaoooooo",
		// "aooooadaaaaaaddaaaaaadaooooa",
		// "aoooaddaddddaddaddddaddaoooa",
		// "aoooaddaaaaaaddaaaaaaddaoooa",
		// "oaooaddaddddaddaddddaddaoooa",
		// "oaoadddaaaaaaddaaaaaadddaoao",
		// "oaoaddddddddddddddddddddaoao",
		// "ooaadddddaaddddddaadddddaaoo",
		// "oooadddddaaddddddaadddddaooo",
		// "oooadddddddddaadddddddddaooo",		 
		// "ooooaddddddaabbaaddddddaoooo",		 
		// "ooooaddddddabaabaddddddaoooo",	 
		// "ooooadddddabahhabadddddaoooo",		 
		// "oooooaddddabahhabaddddaooooo",		 
		// "ooooooaddddabaabaddddaoooooo",		 
		// "oooooooadddaabbaadddaooooooo",
		// "ooooooooaddddaaddddaoooooooo",
		// "oooooooooaaaddddaaaooooooooo",
		// "ooooooooaaooaaaaooaaoooooooo",
		// "oooooooaooooooooooooaooooooo",
		// "ooooooaooooooooooooooaoooooo",
		// "oooooaooooooooooooooooaooooo",
	// };
	// pic数据(显存, 28, 0, 0, &naomi[0][0], 28, 26, -1);
	// 返回;
// }

空 pic数据(无符号 整型 *显存, 整型 x大小, 整型 px, 整型 py, 无符号 字符 *数据, 整型 sx, 整型 sy, 整型 bc)
{
	整型 i = 0, x, y, 像素深度 = 获取_像素深度();
	无符号 字符  *cp, c;
	无符号 短整型 *sp;
	无符号 整型   *ip;
	若 (像素深度 == 8) 
	{
		循环 (y = 0; y < sy; y++) 
		{
			cp = (无符号 字符 *) 显存 + (py + y) * x大小 + px;
			循环 (x = 0; x < sx; x++) 
			{
				c = 数据[y * sx + x];
				若 ('a' <= c && c <= 'p') 
				{
					/* 0～15 */
					cp[x] = c - 0x61;
				} 
				则 若 ('q' <= c && c <= 'r') 
				{
					/* SSXOS颜色 */
					cp[x] = c - 0x61 + 224;
				} 
				则 若 (c == '.') 
				{
					/* 透明色 */
					cp[x] = bc;
				}
			}
		}
	} 
	则 若 (像素深度 == 16) 
	{
		循环 (y = 0; y < sy; y++) 
		{
			sp = (无符号 短整型 *) 显存 + (py + y) * x大小 + px;
			循环 (x = 0; x < sx; x++) 
			{
				c = 数据[y * sx + x];
				若 ('a' <= c && c <= 'p') 
				{
					/* 0～15 */
					i = 获取_颜色(1, c - 0x61);
					sp[x] = 获取_颜色(像素深度, i);
				} 
				则 若 ('r' <= c && c <= 's') 
				{
					/* SSXOS颜色 */
					i = 获取_颜色(1, c + 0x71);
					sp[x] = 获取_颜色(像素深度, i);
				} 
				则 若 (c == '.') 
				{
					/* 透明色 */
					sp[x] = bc;
				}
			}
		}
	} 
	则 若 (像素深度 == 24) 
	{
		循环 (y = 0; y < sy; y++) 
		{
			ip = 显存 + (py + y) * x大小 + px;
			循环 (x = 0; x < sx; x++) 
			{
				c = 数据[y * sx + x];
				若 ('a' <= c && c <= 'p') 
				{
					/* 0～15 */
					i = 获取_颜色(1, c - 0x61);
					ip[x] = 获取_颜色(像素深度, i);
				} 
				则 若 ('r' <= c && c <= 's') 
				{
					/* SSXOS颜色 */
					i = 获取_颜色(1, c + 0x71);
					ip[x] = 获取_颜色(像素深度, i);
				} 
				则 若 (c == '.') 
				{
					/* 透明色 */
					ip[x] = bc;
				}
			}
		}
	}
	返回;
}
