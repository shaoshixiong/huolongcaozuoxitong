/* 控制台相关的 */
/* 作者 : 邵世雄 */
#引入 "主程序.头"
#引入 <标准输入输出.头>
#引入 <string.头>
整型 atoi(恒定 字符 *nptr);

空 控制台_任(结构 图层 *图层, 整型 内存总计)
{
	结构 任务 *任 = 任_当前();
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	整型 i, j = 0, k = 0;
	整型 *文件分配表 = (整型 *) 内管_分配_4k(内管, 4 * 2880);
	字符 *命令行 = (字符 *) 内管_分配_4k(内管, 30 * 21);
	结构 文件句柄 文件句柄[8];
	无符号 字符 *chinese = (字符 *) *((整型 *) 0x0fe8);
	结构 控制台 控制台;
	控制台.层    = 图层;
	控制台.curx   =     8;
	控制台.cury   =    28;
	控制台.curcol =    -1;
	任->控制台 = &控制台;
	任->命令行 = 命令行;

	循环 (i = 0; i < 30 * 21; i++) 
	{
		命令行[i] = 0;
	}

	若 (控制台.层 != 0) 
	{
		控制台.定时 = 定时_分配();
		定时_初始化(控制台.定时, &任->进出, 1);
		定时_设置时间(控制台.定时, 50);
	}
	文件_读取文件分配表(文件分配表, (无符号 字符 *) (地址_磁盘镜像 + 0x000200));
	循环 (i = 0; i < 8; i++) 
	{
		文件句柄[i].buf = 0;	/* 未使用标记 */
	}
	任->文件句柄 = 文件句柄;
	任->文件分配表 = 文件分配表;

	/* 判断是否装载汉字字库 */
	若 (chinese[4096] != 0xff) 
	{
		任->语言模式 = 1;
	} 
	则 
	{
		任->语言模式 = 0;
	}
	任->语言字节1 = 0;

	/* 显示提示符 */
	控制台_放入字符(&控制台, '>', 1);

	循环 (;;) 
	{
		出入流_cli();
		若 (进出32_状态(&任->进出) == 0) 
		{
			任_睡眠(任);
			出入流_sti();
		} 
		则 
		{
			i = 进出32_获取(&任->进出);
			出入流_sti();
			若 (i <= 1 && 控制台.层 != 0) 
			{
				/* 用于curcol */
				若 (i) 
				{
					定时_初始化(控制台.定时, &任->进出, 0);
					若 (控制台.curcol >= 0)
						控制台.curcol = 0x000000;
				} 
				则 
				{
					定时_初始化(控制台.定时, &任->进出, 1);
					若 (控制台.curcol >= 0)
						控制台.curcol = 0xffffff;
				}
				定时_设置时间(控制台.定时, 50);
			}
			若 (i == 2) 
			{
				/* 打开curcol */
				控制台.curcol = 0xffffff;
			}
			若 (i == 3) 
			{
				/* 关闭curcol */
				若 (控制台.层 != 0) 
				{
					实体盒((无符号 整型 *) (控制台.层->buf), 控制台.层->bx大小,
							0x000000, 控制台.curx, 控制台.cury, 控制台.curx + 7, 控制台.cury + 15);
				}
				控制台.curcol = -1;
			}
			若 (i == 4) 
			{
				/* 点击控制台关闭按钮 */
				命令_exit(&控制台, 文件分配表);
			}
			若 (256 <= i && i < 512) 
			{
				/* 键盘数据 */
				i -= 256;	// 先拉
				若 (i == 0x01) 
				{
					/*  */
					/* 删除当前控件的所有字符 */
					控制台_放入字符(&控制台, ' ', 0);
					当 (控制台.curx > 16) 
					{
						控制台.curx -= 8;
						控制台_放入字符(&控制台, ' ', 0);
					}
				} 
				则 若 (i == 0x08) 
				{
					/* 退格键 */
					若 (控制台.curx > 16) 
					{
						控制台_放入字符(&控制台, ' ', 0);
						控制台.curx -= 8;
						控制台_放入字符(&控制台, ' ', 0);
					}
				} 
				则 若 (i == 0x0a) 
				{
					/* 回车键 */
					控制台_放入字符(&控制台, ' ', 0);
					命令行[控制台.curx / 8 - 2] = 0;
					k = 0;
					循环 (i = 0; i < 30; i++) 
					{
						/* 与之前命令比较 */
						若 (命令行[i] == 命令行[30 + i])
							k++;
					}
					若 (i != k && 控制台.curx / 8 - 2 > 0) 
					{
						/* 与之前命令不同 */
						/*  错开指令做筛选 */
						循环 (j = 20; 0 < j; j--) 
						{
							循环 (i = 0; i < 30; i++) 
							{
								命令行[30 * j + i] = 命令行[30 * (j - 1) + i];
								若 (命令行[30 * j + i] == 0) 
								{
									终止;
								}
							}
						}
					}
					j = 0;
					控制台_新行(&控制台);
					控制台_运行命令(命令行, &控制台, 文件分配表, 内存总计);
					若 (控制台.层 == 0) 
					{
						命令_exit(&控制台, 文件分配表);
					}
					/*图层表示 */
					控制台_放入字符(&控制台, '>', 1);
				} 
				则 若 (i == 0xb8) 
				{
					/* Up 键 */
					若 (j < 20) 
					{
						若 (命令行[(j + 1) * 30] != 0) 
						{
							/* 先经过一个 */
							j++;
							控制台_recent(&控制台, 命令行, j);
						}
					}
				} 
				则 若 (i == 0xb2) 
				{
					/* Down 键 */
					若 (1 < j) 
					{
						j--;
						控制台_recent(&控制台, 命令行, j);
					}
				} 
				则 
				{
					/* 一般文字 */
				 	若 (控制台.curx < 控制台_SIZEX) 
					{
						命令行[控制台.curx / 8 - 2] = i;
						控制台_放入字符(&控制台, i, 1);
					}
				}
			}
			/* 再次显示光标 */
			若 (控制台.层 != 0) 
			{
				若 (控制台.curcol >= 0) 
				{
					实体盒((无符号 整型 *) (控制台.层->buf), 控制台.层->bx大小, 
							控制台.curcol, 控制台.curx, 控制台.cury + 15, 控制台.curx + 7, 控制台.cury + 15);
				}
				图层_刷新(控制台.层, 控制台.curx, 控制台.cury + 15, 控制台.curx + 8, 控制台.cury + 16);
			}
		}
	}
}

空 控制台_放入字符(结构 控制台 *控制台, 整型 chr, 字符 move)
{
	字符 s[2];
	s[0] = chr;
	s[1] = 0;

	若 (s[0] == 0x09) 
	{
		/* Tab */
		循环 (;;) 
		{
			若 (控制台->层 != 0) 
			{
				打印字体s_asc_层(控制台->层, 控制台->curx, 控制台->cury, 0xffffff, 0x000000, " ", 1);
			}
			控制台->curx += 8;
			若 (控制台->curx == 8 + 控制台_SIZEX) 
			{
				控制台_新行(控制台);
			}
			若 (((控制台->curx - 8) & 0x1f) == 0) 
			{
				终止;	/* 32除尽就结束 */
			}
		}
	} 
	则 若 (s[0] == 0x0a) 
	{
		/* 换行 */
		控制台_新行(控制台);
	} 
	则 若 (s[0] == 0x0d) 
	{
		/* 恢复 */
		// 不做任何操作
	} 
	则 
	{
		/* 普通文字 */
		若 (控制台->层 != 0) 
		{
			打印字体s_asc_层(控制台->层, 控制台->curx, 控制台->cury, 0xffffff, 0x000000, s, 1);
		}
		若 (move) 
		{
			控制台->curx += 8;
			若 (控制台->curx == 8 + 控制台_SIZEX) 
			{
				控制台_新行(控制台);
			}
		}
	}
	返回;
}

空 控制台_放入str0(结构 控制台 *控制台, 字符 *s)
{
	循环 (; *s != 0; s++)
		控制台_放入字符(控制台, *s, 1);
	返回;
}

空 控制台_放入str1(结构 控制台 *控制台, 字符 *s, 整型 l)
{
	整型 i;
	循环 (i = 0; i < l; i++)
		控制台_放入字符(控制台, s[i], 1);
	返回;
}

空 控制台_新行(结构 控制台 *控制台)
{
	整型 x, y;
	结构 图层 *图层 = 控制台->层;
	结构 任务 *任 = 任_当前();
	整型 像素深度 = 获取_像素深度();
	无符号 短整型 *sp;
	无符号 整型   *ip;
	若 (控制台->cury < 28 + 控制台_SIZEY - 16) {
		控制台->cury += 16;
	} 
	则 
	{
		/* 滚动 */
		若 (图层 != 0) 
		{
			若 (像素深度 == 8) 
			{
				循环 (y = 28; y < 28 + 控制台_SIZEY - 16; y++) 
				{
					循环 (x = 8; x < 8 + 控制台_SIZEX; x++) 
					{
						图层->buf[x + y * 图层->bx大小] = 图层->buf[x + (y + 16) * 图层->bx大小];
					}
				}
				循环 (y = 28 + 控制台_SIZEY - 16; y < 28 + 控制台_SIZEY; y++) 
				{
					循环 (x = 8; x < 8 + 控制台_SIZEX; x++) 
					{
						图层->buf[x + y * 图层->bx大小] = 获取_颜色(像素深度, 0x000000);
					}
				}
			} 
			则 若 (像素深度 == 16) 
			{
				sp = (无符号 短整型 *) (图层->buf);
				循环 (y = 28; y < 28 + 控制台_SIZEY - 16; y++) 
				{
					循环 (x = 8; x < 8 + 控制台_SIZEX; x++) 
					{
						sp[x + y * 图层->bx大小] = sp[x + (y + 16) * 图层->bx大小];
					}
				}
				循环 (y = 28 + 控制台_SIZEY - 16; y < 28 + 控制台_SIZEY; y++) 
				{
					循环 (x = 8; x < 8 + 控制台_SIZEX; x++) 
					{
						sp[x + y * 图层->bx大小] = 获取_颜色(像素深度, 0x000000);
					}
				}
			} 
			则 若 (像素深度 == 24) 
			{
				ip = (无符号 整型 *) (图层->buf);
				循环 (y = 28; y < 28 + 控制台_SIZEY - 16; y++) 
				{
					循环 (x = 8; x < 8 + 控制台_SIZEX; x++) 
					{
						ip[x + y * 图层->bx大小] = ip[x + (y + 16) * 图层->bx大小];
					}
				}
				循环 (y = 28 + 控制台_SIZEY - 16; y < 28 + 控制台_SIZEY; y++) 
				{
					循环 (x = 8; x < 8 + 控制台_SIZEX; x++) 
					{
						ip[x + y * 图层->bx大小] = 获取_颜色(像素深度, 0x000000);
					}
				}
			}
			图层_刷新(图层, 8, 28, 8 + 控制台_SIZEX, 28 + 控制台_SIZEY);
		}
	}
	控制台->curx = 8;
	若 (任->语言模式 == 1 && 任->语言字节1 != 0) 
	{
		控制台->curx += 8;
	}
	返回;
}

空 控制台_recent(结构 控制台 *控制台, 字符 *命令行, 整型 n)
{
	整型 i;
	/* 删除当前控件的所有字符 */
	控制台_放入字符(控制台, ' ', 0);
	当 (控制台->curx > 16) 
	{
		控制台->curx -= 8;
		控制台_放入字符(控制台, ' ', 0);
	}
	/* 从这开始将n个前的指令复制到现在的指令线并发出 */
	循环 (i = 0; i < 30; i++) 
	{
		命令行[i] = 命令行[n * 30 + i];
		若 (命令行[i] == 0) 
		{
			终止;
		}
		控制台_放入字符(控制台, 命令行[i], 1);
	}
	返回;
}

空 控制台_运行命令(字符 *命令行, 结构 控制台 *控制台, 整型 *文件分配表, 整型 内存总计)
{
	/* 指令运行 */
	若 (strcmp(命令行, "mem") == 0 && 控制台->层 != 0) 
	{
		/* 内存指令 */
		命令_mem(控制台, 内存总计);
	} 
	则 若 (strcmp(命令行, "cls") == 0 && 控制台->层 != 0) 
	{
		/* cls指令 */
		命令_cls(控制台);
	} 
	则 若 (strncmp(命令行, "dir", 3) == 0 &&(命令行[3] == ' ' || 命令行[3] == 0) && 控制台->层 != 0) 
	{
		/* dir指令 */
		命令_dir(控制台, 命令行, 文件分配表);
	} 
	则 若 (strcmp(命令行, "exit") == 0) 
	{
		/* exit指令 */
		命令_exit(控制台, 文件分配表);
	} 
	则 若 (strncmp(命令行, "开始 ", 6) == 0) 
	{
		/* start指令 */
		命令_start(控制台, 命令行, 内存总计);
	} 
	则 若 (strncmp(命令行, "ncst ", 5) == 0) 
	{
		/* ncst指令 */
		命令_ncst(控制台, 命令行, 内存总计);
	} 
	则 若 (strncmp(命令行, "语言模式", 8) == 0 &&(命令行[8] == ' ' || 命令行[8] == 0)) 
	{
		命令_语言模式(控制台, 命令行);
	} 
	则 若 (strcmp(命令行, "reboot") == 0) 
	{
		/* reboot指令 */
		命令_reboot(控制台);
	} 
	则 若 (strcmp(命令行, "ver") == 0 && 控制台->层 != 0) 
	{
		/* ver指令 */
		命令_ver(控制台);
	} 
	则 若 (strncmp(命令行, "history", 7) == 0 && 控制台->层 != 0 &&(命令行[7] == ' ' || 命令行[7] == 0)) 
	{
		/* history指令 */
		命令_history(控制台, 命令行);
	} 
	则 若 (strncmp(命令行, "墙纸paper ", 10) == 0 && 控制台->层 != 0) 
	{
		/* 墙纸paper指令 */
		命令_墙纸paper(控制台, 命令行, 文件分配表);
	} 
	则 若 (strcmp(命令行, "时间") == 0 && 控制台->层 != 0) 
	{
		/* 时间指令 */
		命令_时间(控制台);
	} 
	则 若 (strncmp(命令行, "jpfont", 6) == 0 && 控制台->层 != 0 &&(命令行[6] == ' ' || 命令行[6] == 0)) 
	{
		/* jpfont指令 */
		命令_jpfont(控制台, 命令行, 文件分配表);
	} 
	则 若 (命令行[0] != 0) 
	{
		若 (命令_应用(控制台, 文件分配表, 命令行) == 0) 
		{
			/* 不是指令，也不是空行 */
			控制台_放入str0(控制台, "Command or 文件 not found.\n\n");
		}
	}
	返回;
}

空 命令_mem(结构 控制台 *控制台, 整型 内存总计)
{
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	字符 s[60];
	sprintf(s, "Total: %dKB\nFree : %dKB\n\n", 内存总计 / 1000, 内管_总计(内管) / 1024);
	控制台_放入str0(控制台, s);
	返回;
}

空 命令_cls(结构 控制台 *控制台)
{
	整型 x, y;
	结构 图层 *图层 = 控制台->层;
	整型 像素深度 = 获取_像素深度();
	无符号 短整型 *sp;
	无符号 整型   *ip;
	若 (像素深度 == 8) 
	{
		循环 (y = 28; y < 28 + 控制台_SIZEY; y++)
		{
			循环 (x = 8; x < 8 + 控制台_SIZEX; x++) 
			{
				图层->buf[x + y * 图层->bx大小] = 获取_颜色(像素深度, 0x000000);
			}
		}
	} 
	则 若 (像素深度 == 16) 
	{
		sp = (无符号 短整型 *) (图层->buf);
		循环 (y = 28; y < 28 + 控制台_SIZEY; y++) 
		{
			循环 (x = 8; x < 8 + 控制台_SIZEX; x++) 
			{
				sp[x + y * 图层->bx大小] = 获取_颜色(像素深度, 0x000000);
			}
		}
	} 
	则 若 (像素深度 == 24) 
	{
		ip = (无符号 整型 *) (图层->buf);
		循环 (y = 28; y < 28 + 控制台_SIZEY; y++) 
		{
			循环 (x = 8; x < 8 + 控制台_SIZEX; x++) 
			{
				ip[x + y * 图层->bx大小] = 获取_颜色(像素深度, 0x000000);
			}
		}
	}
	图层_刷新(图层, 8, 28, 8 + 控制台_SIZEX, 28 + 控制台_SIZEY);
	控制台->cury = 28;
	返回;
}

空 命令_dir(结构 控制台 *控制台, 字符 *命令行, 整型 *文件分配表)
{
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	结构 文件信息 *文信;
	结构 任务 *任 = 任_当前();
	整型 i = 0, j, k, 标记 = 0;
	字符 s[30];
	无符号 字符 *目录列表 = 0;
	整型 目录列表_大小, dir_clustno;

	若 (命令行[3] == 0) 
	{
		文信 = (结构 文件信息 *) (地址_磁盘镜像 + 0x002600);
	} 
	则 
	{
		文信 = 文件_搜索(命令行 + 4, (结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
		若 (文信 == 0) 
		{
			控制台_放入str0(控制台, "File not found.\n\n");
			返回;
		}

		若 ((文信->类型 & 0x18) == 0) 
		{
			/* 普通文件 */
			sprintf(s, "文件名称  ext  %7d\n\n", 文信->大小);
			循环 (j = 0; j < 8; j++) 
			{
				s[j] = 文信[i].名称[j];
			}
			s[10] = 文信[i].ext[0];
			s[11] = 文信[i].ext[1];
			s[12] = 文信[i].ext[2];
			控制台_放入str0(控制台, s);
			返回;
		} 
		则 若 ((文信->类型 & 0x08) == 0) 
		{
			i = 0;
			dir_clustno = 文信->clustno;
			循环 (;;) 
			{
				i++;
				dir_clustno = 文件分配表[dir_clustno];
				若 (0xff8 <= dir_clustno) 
				{
					终止;
				}
			}
			目录列表_大小 = 512 * i;
			目录列表 = (字符 *) 内管_分配_4k(内管, 目录列表_大小);
			目录列表 = 文件_加载文件2(文信->clustno, &目录列表_大小, 文件分配表);
			文信 = (结构 文件信息 *) 目录列表;
			标记 = 1; // 目录列表 使用中
		}
	}

	循环 (i = 0; i < 224; i++) 
	{
		若 (i != 0 && (i % 11) == 0) 
		{
			控制台_放入str0(控制台, "More...");
			循环 (;;) 
			{
				出入流_cli();
				若 (进出32_状态(&任->进出) == 0) 
				{
					任_睡眠(任);
					出入流_sti();
				} 
				则 
				{
					k = 进出32_获取(&任->进出);
					出入流_sti();
					若 (256 <= k && k < 512) 
					{
						控制台_新行(控制台);
						终止;
					}
				}
			}
		}
		若 (文信[i].名称[0] == 0x00) 
		{
			终止;
		}
		若 (文信[i].名称[0] != 0xe5) 
		{
			若 ((文信[i].类型 & 0x18) == 0) 
			{
				/* 普通文件 */
				sprintf(s, "文件名称  ext  %7d\n", 文信[i].大小);
				循环 (j = 0; j < 8; j++) 
				{
					s[j] = 文信[i].名称[j];
				}
				s[10] = 文信[i].ext[0];
				s[11] = 文信[i].ext[1];
				s[12] = 文信[i].ext[2];
				控制台_放入str0(控制台, s);
			} 
			则 若 ((文信[i].类型 & 0x08) == 0) 
			{
				/* 目录 */
				sprintf(s, "dirc名称 <DIR>\n");
				循环 (j = 0; j < 8; j++) 
				{
					s[j] = 文信[i].名称[j];
				}
				控制台_放入str0(控制台, s);
			}
		}
	}
	若 (标记 == 1) 
	{
			内管_可用_4k(内管, (整型) 目录列表, 目录列表_大小);
	}
	控制台_新行(控制台);
	返回;
}

空 命令_exit(结构 控制台 *控制台, 整型 *文件分配表)
{
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	结构 任务 *任 = 任_当前();
	结构 图层管理 *层管 = (结构 图层管理 *) *((整型 *) 0x0fe4);
	结构 先进先出32 *进出 = (结构 先进先出32 *) *((整型 *) 0x0fec);
	定时_取消(控制台->定时);
	内管_可用_4k(内管, (整型) 文件分配表, 4 * 2880);
	出入流_cli();
	若 (控制台->层 != 0) 
	{
		进出32_放入(进出, 控制台->层 - 层管->图层s0 + 768);	/* 768~1023 */
	} 
	则 
	{
		进出32_放入(进出, 任 - 任管->任s0 + 1024);	/* 1024~2023 */
	}
	出入流_sti();
	循环 (;;) 
	{
		任_睡眠(任);
	}
}

空 命令_start(结构 控制台 *控制台, 字符 *命令行, 整型 内存总计)
{
	结构 图层管理 *层管 = (结构 图层管理 *) *((整型 *) 0x0fe4);
	结构 图层 *层 = 打开_控制台(层管, 内存总计);
	结构 先进先出32 *进出 = &层->任->进出;
	整型 i;
	图层_位置(层, 32, 4);
	图层_上下(层, 层管->顶);
	/* 在新控制台上一次输入一个字符在命令行中输入的字符 */
	循环 (i = 6; 命令行[i] != 0; i++) 
	{
		进出32_放入(进出, 命令行[i] + 256);
	}
	进出32_放入(进出, 10 + 256);
	控制台_新行(控制台);
	返回;
}

空 命令_ncst(结构 控制台 *控制台, 字符 *命令行, 整型 内存总计)
{
	结构 任务 *任 = 打开_控制台任务(0, 内存总计);
	结构 先进先出32 *进出 = &任->进出;
	整型 i;
	/* 在新控制台上一次输入一个字符在命令行中输入的字符 */
	循环 (i = 5; 命令行[i] != 0; i++) 
	{
		进出32_放入(进出, 命令行[i] + 256);
	}
	进出32_放入(进出, 10 + 256);
	// 控制台_新行(控制台);
	返回;
}

空 命令_语言模式(结构 控制台 *控制台, 字符 *命令行)
{
	结构 任务 *任 = 任_当前();
	无符号 字符 模式;
	静态 无符号 字符 s[21 * 3 - 5] = 
	{
		'A', 'S', 'C', 'I', 'I', ' ', 'M', 'o', 'd', 'e', '.', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0x93, 0xFA, 0x96, 0x7B, 0x8C, 0xEA, 0x53, 0x68, 0x69, 0x66, 0x74, 0x4A, 0x49, 0x53, 0x83, 0x82, 0x81, 0x5B, 0x83, 0x68, 0, 
		0xC6, 0xFC, 0xCB, 0xDC, 0xB8, 0xEC, 0x45, 0x55, 0x43, 0xA5, 0xE2, 0xA1, 0xBC, 0xA5, 0xC9, 0
	};

	若 (命令行[8] == 0) 
	{
		/* 无参数指定 */
		控制台_放入str0(控制台, &s[任->语言模式 * 21]);
		控制台_新行(控制台);
		控制台_新行(控制台);
		返回;
	}

	模式 = 命令行[9] - '0';
	若 (模式 <= 2) 
	{
		任->语言模式 = 模式;
		控制台_放入str0(控制台, &s[模式 * 21]);
		控制台_新行(控制台);
	} 
	则 
	{
		控制台_放入str0(控制台, "Mode number error.\n");
	}
	控制台_新行(控制台);
	返回;
}

空 命令_reboot(结构 控制台 *控制台)
{
	出入流_cli();
	wait_KBC_sendready();
	出入流_out8(PORT_KEYCMD, 0xfe); /* 重新启动 */
	循环 (;;)
		出入流_hlt();
}

空 命令_ver(结构 控制台 *控制台)
{
	控制台_放入str0(控制台, 火龙_版本1);
	控制台_放入str0(控制台, 火龙_版本2);
	返回;
}

空 命令_history(结构 控制台 *控制台, 字符 *命令行)
{
	字符 s[40], s2[30];
	整型 i, j, num = 0;

	/* 参数已指定 */
	若 (*(命令行 + 7) != 0) 
	{
		num = atoi(命令行 + 8);
		若 (0 < num && num < 21) 
		{
			循环 (i = 0; i < 30; i++) 
			{
				s2[i] = 命令行[30 * num + i];
			}
			sprintf(s, "[%d] %s\n\n", num, s2);
			控制台_放入str0(控制台, s);
		} 
		则 
		{
			/* 如果指定了超过历史保存数目或小于1，则显示使用方法。 */
			控制台_放入str0(控制台, "using> history [1-20]\n\n");
		}
		返回;
	}

	/* 未指定参数，因此显示全部历史。 */
	循环 (j = 20; 0 < j; j--) 
	{
		循环 (i = 0; i < 30; i++) 
		{
			s2[i] = 命令行[30 * j + i];
			若 (s2[i] == 0) 
			{
				终止;	/* 字符串排到零 */
			}
		}
		若 (s2[0] == 0) 
		{
			/* 没有经过 */
			继续;
		}
		sprintf(s, "[%d] %s\n", j, s2);
		控制台_放入str0(控制台, s);
	}
	控制台_放入str0(控制台, "\n");
	返回;
}

空 命令_墙纸paper(结构 控制台 *控制台, 字符 *命令行, 整型 *文件分配表)
{
	结构 图层管理 *层管 = (结构 图层管理 *) *((整型 *) 0x0fe4);
	结构 图层 *层 = 层管->图层s[0];
	结构 绘画 *墙纸;

	若 (命令行[10] == '0' && 命令行[11] == 0) 
	{
		/* 关闭壁纸 */
		初始化_屏幕((无符号 整型 *) (层->buf), 层->bx大小, 层->by大小);
	} 
	则 
	{
		/* 壁纸显示 */
		墙纸 = 描绘_初始化(命令行 + 10, 文件分配表);
		若 (墙纸->错 == 1) 
		{
			控制台_放入str0(控制台, "File not found.\n\n");
			返回;
		}
		若 (墙纸->错 == 2) 
		{
			控制台_放入str0(控制台, "File is not 描绘.\n\n");
			返回;
		}
		若 ((墙纸->信息[2] > 层->bx大小) | (墙纸->信息[3] > 层->by大小)) 
		{
			/* 画面中超出 */
			控制台_放入str0(控制台, "Picture is too big.\n\n");
			返回;
		}
		/* 显示处理 */
		若 ((墙纸->信息[2] < 层->bx大小) | (墙纸->信息[3] < 层->by大小)) 
		{
			/* 如果图像小于画面大小，则用背景色填充 */
			初始化_屏幕((无符号 整型 *) (层->buf), 层->bx大小, 层->by大小);
		}
		若 (描绘_画(层, 墙纸, (层->bx大小-墙纸->信息[2])/2, (层->by大小-墙纸->信息[3])/2) != 0) 
		{
			控制台_放入str0(控制台, "Picture 解码 error.\n\n");
			返回;
		}
		描绘_可用(墙纸);
	}
	图层_刷新(层, 0, 0, 层->bx大小, 层->by大小);
	控制台_新行(控制台);
	返回;
}

空 命令_时间(结构 控制台 *控制台)
{
	整型 i, t[6];
	字符 s[18];
	循环 (i = 0; i < 7; i++) 
	{
		t[i] = rtc_获取(i);
	}
	sprintf(s, "%04d/%02d/%02d %02d:%02d:%02d\n", t[0], t[1], t[2], t[3], t[4], t[5]);
	控制台_放入str0(控制台, s);
	控制台_新行(控制台);
	返回;
}

空 命令_jpfont(结构 控制台 *控制台, 字符 *命令行, 整型 *文件分配表)
{
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	结构 任务 *任 = 任_当前();
	结构 文件信息 *文信 = (结构 文件信息 *) (地址_磁盘镜像 + 0x002600);
	无符号 字符 *chinese = (无符号 字符 *) *((整型 *) 0x0fe8);
	外部 字符 mhbm[4096];
	整型 i = *((整型 *) 0x0fd8);

	若 (*(命令行 + 6) == 0) 
	{
		文信 = 文件_搜索("chinese.fnt", (结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
	} 
	则 
	{
		文信 = 文件_搜索(命令行 + 7  , (结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
	}
	若 (文信 != 0) 
	{
		内管_可用_4k(内管, (整型) chinese, i);	/* 先取消上一个字体数据 */
		i = 文信->大小;
		chinese = 文件_加载文件2(文信->clustno, &i, 文件分配表);
		循环 (i = 0; i < 16 * 256; i++) 
		{
			chinese[i] = mhbm[i];	/* 复制半宽部分 */
		}
		*((整型 *) 0x0fe8) = (整型) chinese;
		*((整型 *) 0x0fd8) = i;
		任->语言模式 = 1;
	} 
	则 
	{
		控制台_放入str0(控制台, "Font 数据 not found.\n");
	}
	控制台_新行(控制台);
	返回;
}

整型 命令_应用(结构 控制台 *控制台, 整型 *文件分配表, 字符 *命令行)
{
	结构 内存管理 *内管 = (结构 内存管理 *) 内存管理_地址;
	结构 文件信息 *文信;
	结构 图层管理 *层管;
	结构 图层 *层;
	字符 名称[18], *p, *q;
	结构 任务 *任 = 任_当前();
	整型 i;
	整型 seg大小, dat大小, esp, dat火龙, 应用大小;

	任->语言模式0 = 任->语言模式;

	/*  从命令行生成文件名 */
	循环 (i = 0; i < 13; i++) 
	{
		若 (命令行[i] <= ' ')
			终止;
		名称[i] = 命令行[i];
	}
	名称[i] = 0;

	文信 = 文件_搜索(名称, (结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
	若 (文信 == 0 && 名称[i - 1] != '.') 
	{
		/* 找不到，用EPM重试 */
		名称[i    ] = '.';
		名称[i + 1] = 'e';
		名称[i + 2] = 'p';
		名称[i + 3] = 'm';
		名称[i + 4] = 0;
		文信 = 文件_搜索(名称, (结构 文件信息 *) (地址_磁盘镜像 + 0x002600), 224);
	}
	若 (文信 == 0) 
	{
		/* 仍然不合理 */
		返回 0;
	}

	/* 有一个档案 */
	应用大小 = 文信->大小;
	p = 文件_加载文件2(文信->clustno, &应用大小, 文件分配表);
	若 (应用大小 >= 36 && strncmp(p + 4, "Hari", 4) == 0 && *p == 0x00) 
	{
		seg大小 = *((整型 *) (p + 0x0000));
		esp     = *((整型 *) (p + 0x000c));
		dat大小 = *((整型 *) (p + 0x0010));
		dat火龙  = *((整型 *) (p + 0x0014));
		q = (字符 *) 内管_分配_4k(内管, seg大小);
		任->ds_base = (整型) q;
		设置_segmdesc(任->ldt + 0, 应用大小 - 1, (整型) p, AR_CODE32_ER + 0x60);
		设置_segmdesc(任->ldt + 1, seg大小 - 1, (整型) q, AR_DATA32_RW + 0x60);
		循环 (i = 0; i < dat大小; i++)
			q[esp + i] = p[dat火龙 + i];
		start_应用(0x1b, 0 * 8 + 4, esp, 1 * 8 + 4, &(任->tss.esp0));
		层管 = (结构 图层管理 *) *((整型 *) 0x0fe4);
		循环 (i = 0; i < 最大值_图层S; i++) 
		{
			层 = &(层管->图层s0[i]);
			若 ((层->标记 & 0x11) == 0x11 && 层->标记 && 层->任 == 任) 
			{
				/* 应用程序结束了，但仍有一个底层 */
				图层_可用(层);		/* 关闭 */
			}
		}
		循环 (i = 0; i < 8; i++) 
		{
			/* 关闭未关闭的文件 */
			若 (任->文件句柄[i].buf != 0) 
			{
				内管_可用_4k(内管, (整型) 任->文件句柄[i].buf, 任->文件句柄[i].大小);
				任->文件句柄[i].buf = 0;
			}
		}
		任->语言模式 = 任->语言模式0;		// 撤消API更改的语言模式
		定时_取消所有(&任->进出);
		内管_可用_4k(内管, (整型) q, seg大小);
		任->语言字节1 = 0;
	} 
	则 
	{
		// 控制台_放入str0(控制台, ".epm 文件 循环mat error.\n");
	}
	内管_可用_4k(内管, (整型) p, 应用大小);
	// 控制台_新行(控制台);
	返回 1;
}

/* 火龙_api has moved to 应用程序接口.乙 */

整型 *inthandler0c(整型 *esp)
{
	结构 任务 *任 = 任_当前();
	结构 控制台 *控制台 = 任->控制台;
	字符 s[30];
	控制台_放入str0(控制台, "\nINT 0C :\n Stack Exception.\n");
	sprintf(s, "EIP = %08X", esp[11]);
	控制台_放入str0(控制台, s);
	返回 &(任->tss.esp0);
}

整型 *inthandler0d(整型 *esp)
{
	结构 任务 *任 = 任_当前();
	结构 控制台 *控制台 = 任->控制台;
	字符 s[30];
	控制台_放入str0(控制台, "\nINT 0D :\n General Protected Exception.\n");
	sprintf(s, "EIP = %08X", esp[11]);
	控制台_放入str0(控制台, s);
	返回 &(任->tss.esp0);
}
